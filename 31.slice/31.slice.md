# Go Slice - 

## Slice ‡¶ï‡ßÄ?

**Slice** ‡¶π‡¶≤‡ßã Go-‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ ‡¶°‡ßá‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶Ø‡¶æ Array-‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø ‡¶ï‡¶∞‡ßá ‡¶§‡ßà‡¶∞‡¶ø‡•§ ‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø **dynamic array** ‡¶Ø‡¶æ‡¶∞ size ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§

### Slice-‡¶è‡¶∞ ‡ß©‡¶ü‡¶ø ‡¶Æ‡ßÇ‡¶≤ ‡¶Ö‡¶Ç‡¶∂:
1. **Pointer** ‚Üí underlying array-‡¶∞ ‡¶ï‡ßã‡¶® index ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ
2. **Length** ‚Üí slice-‡¶è ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã element ‡¶Ü‡¶õ‡ßá
3. **Capacity** ‚Üí slice maximum ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã element ‡¶ß‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá (‡¶®‡¶§‡ßÅ‡¶® memory allocate ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá)

```
Slice Structure:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Pointer ‚îÇ Length ‚îÇ Capacity ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
     ‚îî‚îÄ‚îÄ> [underlying array]
```

---

## ‡¶ï‡ßã‡¶° #‡ßß: Slice Basics ‡¶è‡¶¨‡¶Ç Underlying Array

```go
package main

import "fmt"

func main() {
    arr := [6]string{"This", "is", "a", "Go", "Intro", "slice"}
    fmt.Println(arr)

    //slice is a reference to an array
    //slice = pointer + length + capacity

    sl := arr[1:4] //[is a go]

    //pointer =  &arr[1] means the slice starts at index 1 of the array
    //length = 4-1 = 3 means the slice has 3 elements
    //capacity = len(arr) - 1 = 6 - 1 = 5 means the slice can grow up to 5 elements before needing to allocate new memory

    fmt.Println(sl)

    sl1 := sl[1:2]

    fmt.Println(sl1)
    fmt.Println(len(sl1)) //length
    fmt.Println(cap(sl1)) //capacity
    fmt.Println(*&sl1[0])
}
```

### ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡¶æ‡¶á ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß-‡ß©:** Package ‡¶è‡¶¨‡¶Ç import declaration

**‡¶≤‡¶æ‡¶á‡¶® ‡ß¨:**
```go
arr := [6]string{"This", "is", "a", "Go", "Intro", "slice"}
```
- ‡¶è‡¶ï‡¶ü‡¶ø **array** ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶Ø‡¶æ‡¶∞ size ‡ß¨ ‡¶è‡¶¨‡¶Ç type string
- Array-‡¶∞ size fixed ‡¶•‡¶æ‡¶ï‡ßá

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß®:**
```go
sl := arr[1:4]
```
- `arr` ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø **slice** ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- `[1:4]` ‡¶Æ‡¶æ‡¶®‡ßá index ‡ßß ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ, index ‡ß™ ‡¶è‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ (‡ß™ ‡¶®‡¶Ø‡¶º)
- Result: `["is", "a", "Go"]`

**Memory ‡¶§‡ßá ‡¶ï‡ßÄ ‡¶π‡¶ö‡ßç‡¶õ‡ßá:**
```
arr: [This | is | a | Go | Intro | slice]
       0     1    2   3     4       5

sl pointer ‚Üí index 1
sl length = 3 (index 1, 2, 3)
sl capacity = 5 (index 1 ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßá‡¶∑ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ = 6-1 = 5)
```

**‡¶≤‡¶æ‡¶á‡¶® ‡ß®‡ß¶:**
```go
sl1 := sl[1:2]
```
- ‡¶Ü‡¶¨‡¶æ‡¶∞ `sl` ‡¶•‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® slice ‡¶§‡ßà‡¶∞‡¶ø
- `sl[1:2]` ‡¶Æ‡¶æ‡¶®‡ßá `sl`-‡¶è‡¶∞ index ‡ßß ‡¶•‡ßá‡¶ï‡ßá ‡ß® ‡¶è‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§
- Result: `["a"]`

**‡¶≤‡¶æ‡¶á‡¶® ‡ß®‡ß©-‡ß®‡ß™:**
```go
fmt.Println(len(sl1)) // Output: 1
fmt.Println(cap(sl1)) // Output: 4
```
- `len(sl1)` = ‡ßß ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶ï‡¶ü‡¶ø element ‡¶Ü‡¶õ‡ßá
- `cap(sl1)` = ‡ß™ ‡¶ï‡¶æ‡¶∞‡¶£ underlying array-‡¶§‡ßá sl1 ‡¶è‡¶∞ pointer ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßá‡¶∑ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡ß™‡¶ü‡¶ø ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ ‡¶Ü‡¶õ‡ßá

**‡¶≤‡¶æ‡¶á‡¶® ‡ß®‡ß´:**
```go
fmt.Println(*&sl1[0]) // Output: "a"
```
- `sl1[0]` ‡¶è‡¶∞ address ‡¶®‡¶ø‡¶Ø‡¶º‡ßá (`&`) ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ dereference ‡¶ï‡¶∞‡ßá (`*`) value print ‡¶ï‡¶∞‡¶õ‡ßá

---

## ‡¶ï‡ßã‡¶° #‡ß®: Slice ‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶â‡¶™‡¶æ‡¶Ø‡¶º

```go
package main

import "fmt"

func main() {
	s := []int{1, 2, 5} //slice literal

	fmt.Println("slice :", s, "length :", len(s), "capacity :", cap(s))

	//slice declare with make
	//make function with len

	lenSlice := make([]int, 5)

	lenSlice[4] = 10

	fmt.Println(lenSlice)

	//make function with len and capacity
	sliceData := make([]int, 3, 5) //here 3 is length and 5 is capacity and[] is slice literal

	sliceData[0] = 5
	sliceData[1] = 7
	sliceData[2] = 10
	fmt.Println(sliceData)

	//empty slice or nil slice
	var emptySlice []int

	fmt.Println(emptySlice)

	emptySlice = append(emptySlice, 1, 2, 3)

	fmt.Println(emptySlice, len(emptySlice), cap(emptySlice))
}
```

### ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡¶æ‡¶á ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

**‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ßß: Slice Literal (‡¶≤‡¶æ‡¶á‡¶® ‡ß¨)**
```go
s := []int{1, 2, 5}
```
- ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶∏‡¶π‡¶ú ‡¶â‡¶™‡¶æ‡¶Ø‡¶º
- Automatically length = 3, capacity = 3
- Array ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø: `[]int` ‡¶§‡ßá size ‡¶®‡ßá‡¶á

**‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ß®: `make()` ‡¶∂‡ßÅ‡¶ß‡ßÅ Length ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá (‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß©)**
```go
lenSlice := make([]int, 5)
```
- `make([]int, 5)` ‡¶Æ‡¶æ‡¶®‡ßá:
    - Type: `[]int`
    - Length: ‡ß´
    - Capacity: ‡ß´ (length-‡¶è‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶®)
- ‡¶∏‡¶¨ element ‡¶è‡¶∞ default value = `0`

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß´:**
```go
lenSlice[4] = 10
```
- Index ‡ß™ ‡¶è value ‡ßß‡ß¶ set ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- Output: `[0 0 0 0 10]`

**‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ß©: `make()` Length ‡¶è‡¶¨‡¶Ç Capacity ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá (‡¶≤‡¶æ‡¶á‡¶® ‡ß®‡ß¶)**
```go
sliceData := make([]int, 3, 5)
```
- Length: ‡ß© (‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡ß©‡¶ü‡¶ø element ‡¶Ü‡¶õ‡ßá)
- Capacity: ‡ß´ (‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö ‡ß´‡¶ü‡¶ø element ‡¶∞‡¶æ‡¶ñ‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶§‡ßÅ‡¶® allocation ‡¶õ‡¶æ‡¶°‡¶º‡¶æ)

```
Memory:
[0 | 0 | 0 | ? | ?]
 ‚Üê‚îÄ‚îÄ len=3 ‚îÄ‚îÄ‚Üí
 ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ cap=5 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí
```

**‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ß™: Nil Slice (‡¶≤‡¶æ‡¶á‡¶® ‡ß®‡ßÆ)**
```go
var emptySlice []int
```
- Declare ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ initialize ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡¶®‡¶ø
- ‡¶è‡¶ü‡¶ø `nil` slice (length=0, capacity=0, pointer=nil)

**‡¶≤‡¶æ‡¶á‡¶® ‡ß©‡ß®:**
```go
emptySlice = append(emptySlice, 1, 2, 3)
```
- `append()` function ‡¶®‡¶§‡ßÅ‡¶® element ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßá
- Nil slice-‡¶è‡¶ì append ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º
- Output: `[1 2 3]`, length=3, capacity=4 (Go automatically capacity ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶Ø‡¶º)

---

## ‡¶ï‡ßã‡¶° #‡ß©: Slice Copy ‡¶è‡¶¨‡¶Ç Append Behavior

```go
package main

import "fmt"

func main() {
	var data []int

	data = append(data, 1)
	data = append(data, 2)
	data = append(data, 3)

	data2 := data

	data = append(data, 4)
	data2 = append(data2, 5)

	data[0] = 100

	fmt.Println(data)   // Output: [100 2 3 4]
	fmt.Println(data2)  // Output: [1 2 3 5]
}
```

### ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡¶æ‡¶á ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

**‡¶≤‡¶æ‡¶á‡¶® ‡ß¨-‡ßß‡ß¶:**
```go
var data []int
data = append(data, 1)
data = append(data, 2)
data = append(data, 3)
```
- Nil slice ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá ‡¶§‡¶æ‡¶§‡ßá ‡ßß, ‡ß®, ‡ß© ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- Result: `data = [1, 2, 3]`

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß®:**
```go
data2 := data
```
- **Important:** `data2` ‡¶è‡¶¨‡¶Ç `data` ‡¶è‡¶ï‡¶á underlying array point ‡¶ï‡¶∞‡¶õ‡ßá
- ‡¶è‡¶ü‡¶ø shallow copy, deep copy ‡¶®‡¶Ø‡¶º

```
Memory (‡¶è‡¶ñ‡¶® ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§):
data  ‚Üí [1 | 2 | 3]
data2 ‚Üí [1 | 2 | 3]  (same array)
```

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß™:**
```go
data = append(data, 4)
```
- `data`-‡¶§‡ßá ‡ß™ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- ‡¶Ø‡¶¶‡¶ø capacity ‡¶õ‡ßã‡¶ü ‡¶π‡¶Ø‡¶º, Go **‡¶®‡¶§‡ßÅ‡¶® array allocate** ‡¶ï‡¶∞‡ßá
- ‡¶è‡¶ñ‡¶® `data` ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶§‡ßÅ‡¶® array point ‡¶ï‡¶∞‡¶õ‡ßá

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß´:**
```go
data2 = append(data2, 5)
```
- `data2`-‡¶§‡ßá ‡ß´ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- `data2` ‡¶ì ‡¶®‡¶§‡ßÅ‡¶® array ‡¶™‡ßá‡¶Ø‡¶º‡ßá‡¶õ‡ßá

```
Memory (‡¶è‡¶ñ‡¶®):
data  ‚Üí [1 | 2 | 3 | 4]  (new array)
data2 ‚Üí [1 | 2 | 3 | 5]  (new array)
```

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß≠:**
```go
data[0] = 100
```
- ‡¶∂‡ßÅ‡¶ß‡ßÅ `data` ‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ element ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶π‡¶¨‡ßá
- `data2` unchanged ‡¶•‡¶æ‡¶ï‡¶¨‡ßá ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶è‡¶∞‡¶æ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ array

**Output:**
- `data`: `[100 2 3 4]`
- `data2`: `[1 2 3 5]`

**‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ:** `append()` ‡¶Ø‡¶ñ‡¶® capacity exceed ‡¶ï‡¶∞‡ßá, ‡¶§‡¶ñ‡¶® ‡¶®‡¶§‡ßÅ‡¶® array ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶Ø‡¶º‡•§

---

## ‡¶ï‡ßã‡¶° #‡ß™: Function-‡¶è Slice Pass ‡¶ï‡¶∞‡¶æ ‡¶è‡¶¨‡¶Ç Modification

```go
package main

import "fmt"

func main() {
	x := []int{1, 2, 3, 4, 5}
	x = append(x, 6)
	x = append(x, 7)

	a := x[4:]

	y := changeSlice(a)

	fmt.Println(x)  // Output: [1 2 3 4 10 6 7]
	fmt.Println(y)  // Output: [10 6 7 11]
}

func changeSlice(sliceNum []int) []int {
	sliceNum[0] = 10
	return append(sliceNum, 11)
}
```

### ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡¶æ‡¶á ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

**‡¶≤‡¶æ‡¶á‡¶® ‡ß¨-‡ßÆ:**
```go
x := []int{1, 2, 3, 4, 5}
x = append(x, 6)
x = append(x, 7)
```
- `x = [1, 2, 3, 4, 5, 6, 7]`

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß¶:**
```go
a := x[4:]
```
- `x`-‡¶è‡¶∞ index ‡ß™ ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßá‡¶∑ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ slice
- `a = [5, 6, 7]`
- **Important:** `a` ‡¶è‡¶¨‡¶Ç `x` ‡¶è‡¶ï‡¶á underlying array ‡¶∂‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶õ‡ßá

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß®:**
```go
y := changeSlice(a)
```
- `a` ‡¶ï‡ßá function-‡¶è pass ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá

**Function (‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ßÆ-‡ß®‡ßß):**
```go
func changeSlice(sliceNum []int) []int {
	sliceNum[0] = 10
	return append(sliceNum, 11)
}
```

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ßØ:**
```go
sliceNum[0] = 10
```
- `sliceNum` ‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ element ‡ßß‡ß¶ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- ‡¶Ø‡ßá‡¶π‡ßá‡¶§‡ßÅ `sliceNum` ‡¶è‡¶¨‡¶Ç `a` (‡¶è‡¶¨‡¶Ç `x`) ‡¶è‡¶ï‡¶á array ‡¶∂‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá, ‡¶§‡¶æ‡¶á `x[4]` ‡¶ì ‡ßß‡ß¶ ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá

**‡¶≤‡¶æ‡¶á‡¶® ‡ß®‡ß¶:**
```go
return append(sliceNum, 11)
```
- `sliceNum`-‡¶è ‡ßß‡ßß ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- `append()` ‡¶®‡¶§‡ßÅ‡¶® slice return ‡¶ï‡¶∞‡ßá

**Memory Visualization:**
```
Before changeSlice:
x: [1 | 2 | 3 | 4 | 5 | 6 | 7]
                    ‚Üë
                    a points here

After sliceNum[0] = 10:
x: [1 | 2 | 3 | 4 | 10 | 6 | 7]
                    ‚Üë
                    (modified)

After append:
y: [10 | 6 | 7 | 11]  (new array)
```

**Output:**
- `x`: `[1 2 3 4 10 6 7]` (index ‡ß™ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá)
- `y`: `[10 6 7 11]` (‡¶®‡¶§‡ßÅ‡¶® slice)

**‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ:**
- Slice pass ‡¶ï‡¶∞‡¶≤‡ßá underlying array modify ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
- ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ `append()` ‡¶®‡¶§‡ßÅ‡¶® slice ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá

---

## ‡¶ï‡ßã‡¶° #‡ß´: Variadic Function (... ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶ü‡¶∞)

```go
package main

import "fmt"

func printVar(nums ...int) {
	fmt.Println(nums)
	fmt.Println(len(nums))
	fmt.Println(cap(nums))
}

func main() {
	printVar(5, 5, 6, 7, 8, 11, 15)
}
```

### ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡¶æ‡¶á ‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ:

**‡¶≤‡¶æ‡¶á‡¶® ‡ß´:**
```go
func printVar(nums ...int) {
```
- `...int` ‡¶Æ‡¶æ‡¶®‡ßá **variadic parameter**
- ‡¶è‡¶á function ‡¶Ø‡¶§‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ñ‡ßÅ‡¶∂‡¶ø `int` argument ‡¶®‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá
- Function-‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞‡ßá `nums` ‡¶è‡¶ï‡¶ü‡¶ø slice ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá

**‡¶≤‡¶æ‡¶á‡¶® ‡ßß‡ß®:**
```go
printVar(5, 5, 6, 7, 8, 11, 15)
```
- ‡ß≠‡¶ü‡¶ø argument pass ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
- Go automatically ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá ‡¶è‡¶ï‡¶ü‡¶ø slice `[]int{5, 5, 6, 7, 8, 11, 15}` ‡¶¨‡¶æ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶¶‡ßá‡¶Ø‡¶º

**Output:**
```
[5 5 6 7 8 11 15]
7
7
```

**‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá:**
```go
// You call:
printVar(1, 2, 3)

// Go converts it to:
nums := []int{1, 2, 3}
printVar(nums)
```

**Variadic-‡¶è‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞:**
```go
// Existing slice pass ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá:
mySlice := []int{10, 20, 30}
printVar(mySlice...)  // ... ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá slice expand ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá
```

---

## ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ Slice Concepts ‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™

### ‡ßß. **Slice vs Array**

| Array | Slice |
|-------|-------|
| Fixed size: `[5]int` | Dynamic size: `[]int` |
| Value type | Reference type |
| Copy ‡¶ï‡¶∞‡¶≤‡ßá ‡¶™‡ßÅ‡¶∞‡ßã array copy ‡¶π‡¶Ø‡¶º | Copy ‡¶ï‡¶∞‡¶≤‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ pointer copy ‡¶π‡¶Ø‡¶º |

### ‡ß®. **Length vs Capacity**

```go
s := make([]int, 3, 5)
// len(s) = 3 ‚Üí ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã element access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá
// cap(s) = 5 ‚Üí ‡¶Æ‡ßã‡¶ü ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã element ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ ‡¶Ü‡¶õ‡ßá
```

### ‡ß©. **Append ‡¶è‡¶∞ Behavior**

```go
s := []int{1, 2, 3}
s = append(s, 4)  // capacity ‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶•‡¶æ‡¶ï‡¶≤‡ßá same array
s = append(s, 5)  // capacity ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá new array allocate ‡¶π‡¶Ø‡¶º
```

**Growth Pattern:** Go ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ capacity ‡¶¶‡ßç‡¶¨‡¶ø‡¶ó‡ßÅ‡¶£ ‡¶ï‡¶∞‡ßá (2x growth)

### ‡ß™. **Nil Slice vs Empty Slice**

```go
var nilSlice []int        // nil slice (len=0, cap=0, pointer=nil)
emptySlice := []int{}     // empty slice (len=0, cap=0, but not nil)
emptySlice2 := make([]int, 0)  // empty slice
```

### ‡ß´. **Common Operations**

```go
// Slice creation
s := []int{1, 2, 3}
s := make([]int, 5)
s := make([]int, 3, 5)

// Slicing
s[1:3]   // index 1 ‡¶•‡ßá‡¶ï‡ßá 2 ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§
s[:3]    // ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶•‡ßá‡¶ï‡ßá 2 ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§
s[2:]    // index 2 ‡¶•‡ßá‡¶ï‡ßá ‡¶∂‡ßá‡¶∑ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§
s[:]     // ‡¶™‡ßÅ‡¶∞‡ßã slice

// Append
s = append(s, 4)           // ‡¶è‡¶ï‡¶ü‡¶ø element
s = append(s, 5, 6, 7)     // ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï element
s = append(s, anotherSlice...)  // ‡¶Ü‡¶∞‡ßá‡¶ï‡¶ü‡¶ø slice

// Copy
dest := make([]int, len(src))
copy(dest, src)  // src ‡¶•‡ßá‡¶ï‡ßá dest-‡¶è copy
```

---

## ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶≠‡ßÅ‡¶≤ ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®

### ‚ùå ‡¶≠‡ßÅ‡¶≤ #‡ßß: Index Out of Range
```go
s := make([]int, 3, 5)
s[4] = 10  // Panic! len=3, ‡¶§‡¶æ‡¶á index 3+ access ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ
```
‚úÖ **‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®:**
```go
s = append(s, 0, 10)  // ‡¶Ü‡¶ó‡ßá length ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶§‡ßá ‡¶π‡¶¨‡ßá
```

### ‚ùå ‡¶≠‡ßÅ‡¶≤ #‡ß®: Append Return Value Ignore ‡¶ï‡¶∞‡¶æ
```go
s := []int{1, 2, 3}
append(s, 4)  // ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá ‡¶®‡¶æ!
```
‚úÖ **‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®:**
```go
s = append(s, 4)  // return value assign ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶¨‡ßá
```

### ‚ùå ‡¶≠‡ßÅ‡¶≤ #‡ß©: Slice Sharing Unaware
```go
s1 := []int{1, 2, 3}
s2 := s1
s2[0] = 100
// s1 ‡¶ì ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§ ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá!
```
‚úÖ **‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®:**
```go
s2 := make([]int, len(s1))
copy(s2, s1)  // Deep copy
```

---

## Best Practices ‚ú®

1. **Pre-allocate ‡¶Ø‡¶ñ‡¶® size ‡¶ú‡¶æ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡ßá:**
   ```go
   s := make([]int, 0, 100)  // capacity ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá allocation ‡¶ï‡¶Æ‡¶æ‡¶ì
   ```

2. **Append ‡¶∏‡¶¨‡¶∏‡¶Æ‡¶Ø‡¶º assign ‡¶ï‡¶∞‡ßã:**
   ```go
   s = append(s, newElement)
   ```

3. **Large slice copy ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡¶§‡¶∞‡ßç‡¶ï ‡¶•‡¶æ‡¶ï‡ßã:**
   ```go
   // Shallow copy (fast but shares memory)
   s2 := s1
   
   // Deep copy (slow but independent)
   s2 := make([]int, len(s1))
   copy(s2, s1)
   ```

4. **Slice ‡¶ï‡ßá function argument ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá pass ‡¶ï‡¶∞‡¶≤‡ßá ‡¶∏‡¶æ‡¶¨‡¶ß‡¶æ‡¶®:**
    - Element modify ‡¶π‡¶≤‡ßá original slice-‡¶ì change ‡¶π‡¶¨‡ßá
    - Append ‡¶ï‡¶∞‡¶≤‡ßá ‡¶®‡¶§‡ßÅ‡¶® slice ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶¨‡ßá

---

## ‡¶â‡¶™‡¶∏‡¶Ç‡¶π‡¶æ‡¶∞ üéì

Go-‡¶è‡¶∞ Slice ‡¶π‡¶≤‡ßã:
- ‚úÖ Flexible ‡¶è‡¶¨‡¶Ç powerful
- ‚úÖ Dynamic size ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø perfect
- ‚úÖ Memory efficient (underlying array ‡¶∂‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá)
- ‚ö†Ô∏è Reference type ‡¶§‡¶æ‡¶á side effects ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶∏‡¶ö‡ßá‡¶§‡¶® ‡¶•‡¶æ‡¶ï‡¶§‡ßá ‡¶π‡¶¨‡ßá

**‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡ßã:**
```
Slice = Pointer + Length + Capacity
```

‡¶è‡¶á ‡ß´‡¶ü‡¶ø ‡¶ï‡ßã‡¶° ‡¶è‡¶¨‡¶Ç ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ practice ‡¶ï‡¶∞‡¶≤‡ßá Go Slice-‡¶è expert ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá! üí™