# Go рждрзЗ Separate Stack For Separate Thread- рж╕рж╣ржЬ ржмрзНржпрж╛ржЦрзНржпрж╛

## Stack ржХрзА?

Stack рж╣рж▓рзЛ memory-рж░ ржПржХржЯрж┐ ржмрж┐рж╢рзЗрж╖ ржЕржВрж╢ ржпрзЗржЦрж╛ржирзЗ рж░рж╛ржЦрж╛ рж╣ржпрж╝:
- Function ржПрж░ local variables
- Function call ржПрж░ information
- Return address (function рж╢рзЗрж╖рзЗ ржХрзЛржерж╛ржпрж╝ ржлрж┐рж░ржмрзЗ)

**ржЙржжрж╛рж╣рж░ржг:**
```
Function call: A() тЖТ B() тЖТ C()

Stack ржП рж░рж╛ржЦрж╛ рж╣ржмрзЗ:
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ  C() data   тФВ тЖР ржПржЦржи ржПржЦрж╛ржирзЗ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  B() data   тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  A() data   тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

---

## ржорзВрж▓ Concept: Separate Stack for Separate Thread

### ржХрзЗржи ржкрзНрж░рждрж┐ржЯрж┐ Thread ржПрж░ ржЖрж▓рж╛ржжрж╛ Stack ржкрзНрж░ржпрж╝рзЛржЬржи?

ржПржЯрж╛ concurrent programming ржПрж░ **рж╕ржмржЪрзЗржпрж╝рзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг concept**!

### Problem ржпржжрж┐ Shared Stack ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж┐:

```
тЭМ ржПржХржЯрж╛ржЗ Stack (рж╕ржорж╕рзНржпрж╛):

Thread 1:                Thread 2:
functionA() {            functionB() {
  int x = 10;              int y = 20;
  ...                      ...
}                        }

        тЖУ тЖУ
   ржПржХржЗ Stack ржмрзНржпржмрж╣рж╛рж░
        тЖУ тЖУ
        
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ x=10, y=20      тФВ тЖР Data ржорж┐рж╢рзЗ ржЧрзЗржЫрзЗ!
тФВ ржХрзЛржиржЯрж╛ ржХрж╛рж░?      тФВ тЖР Confusion!
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

Result: ЁЯТе Crash ржмрж╛ Wrong Result
```

### Solution: ржЖрж▓рж╛ржжрж╛ Stack (рж╕ржарж┐ржХ ржЙржкрж╛ржпрж╝):

```
тЬЕ ржкрзНрж░рждрж┐ржЯрж┐ Thread ржПрж░ ржирж┐ржЬрж╕рзНржм Stack:

Thread 1:                Thread 2:
functionA() {            functionB() {
  int x = 10;              int y = 20;
  ...                      ...
}                        }
    тЖУ                        тЖУ
    
Thread 1 Stack:      Thread 2 Stack:
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР     тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ x = 10      тФВ     тФВ y = 20      тФВ
тФВ local vars  тФВ     тФВ local vars  тФВ
тФВ return addr тФВ     тФВ return addr тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ     тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

Result: тЬЕ ржХрзЛржи Conflict ржирзЗржЗ!
```

---

## Thread Stack Isolation - ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд

### 1. Memory Isolation (ржорзЗржорж░рж┐ ржЖрж▓рж╛ржжрж╛)

ржкрзНрж░рждрж┐ржЯрж┐ thread ржПрж░ stack **рж╕ржорзНржкрзВрж░рзНржг ржЖрж▓рж╛ржжрж╛ memory region** ржП ржерж╛ржХрзЗ:

```
Complete Memory View:
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ  Thread 1 Stack Region          тФВ тЖР Address: 0x1000-0x2000
тФВ  [Local Vars, Function Calls]   тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  Thread 2 Stack Region          тФВ тЖР Address: 0x3000-0x4000
тФВ  [Local Vars, Function Calls]   тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  Thread 3 Stack Region          тФВ тЖР Address: 0x5000-0x6000
тФВ  [Local Vars, Function Calls]   тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  Shared Heap (рж╕ржмрж╛ржЗ access ржХрж░рзЗ) тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

### 2. Function Call Stack Frame

ржкрзНрж░рждрж┐ржЯрж┐ function call ржПрж░ ржЬржирзНржп ржПржХржЯрж╛ **stack frame** рждрзИрж░рж┐ рж╣ржпрж╝:

```
Thread Stack ржП ржПржХржЯрж╛ Function Call:

тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР  тЖР Stack Top
тФВ  Return Address         тФВ  (ржХрзЛржерж╛ржпрж╝ ржлрж┐рж░ржмрзЗ)
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  Function Parameters    тФВ  (ржпрзЗ values pass ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ)
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  Local Variables        тФВ  (function ржПрж░ ржнрж┐рждрж░рзЗрж░ vars)
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  Saved Registers        тФВ  (CPU register values)
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ  тЖР Stack Frame
```

### 3. Real Example - Stack Separation

```go
package main

import (
    "fmt"
    "time"
)

func calculateSum(threadID int) {
    // ржПржЗ variables ржПржЗ goroutine ржПрж░ ржирж┐ржЬрж╕рзНржм stack ржП ржерж╛ржХржмрзЗ
    sum := 0
    numbers := []int{1, 2, 3, 4, 5}
    
    for _, num := range numbers {
        sum += num
        fmt.Printf("Thread %d: sum = %d (Stack Address: %p)\n", 
                   threadID, sum, &sum)
    }
    
    // ржкрзНрж░рждрж┐ржЯрж┐ thread ржПрж░ sum variable ржЖрж▓рж╛ржжрж╛ address ржП!
}

func main() {
    // 3ржЯрж┐ goroutine рждрзИрж░рж┐ ржХрж░рж┐
    for i := 1; i <= 3; i++ {
        go calculateSum(i)
    }
    
    time.Sleep(2 * time.Second)
}
```

**Output ржжрзЗржЦрзБржи:**
```
Thread 1: sum = 15 (Stack Address: 0xc000012078)
Thread 2: sum = 15 (Stack Address: 0xc000012098)
Thread 3: sum = 15 (Stack Address: 0xc0000120b8)

рж▓ржХрзНрж╖рзНржп ржХрж░рзБржи: ржкрзНрж░рждрж┐ржЯрж┐ thread ржПрж░ sum variable 
ржЖрж▓рж╛ржжрж╛ memory address ржП! ржПржЯрж╛ржЗ Stack Separation!
```

---

## Stack Separation ржПрж░ рж╕рзБржмрж┐ржзрж╛

### тЬЕ 1. Thread Safety
```
Thread 1 ржПрж░ data тЖТ Thread 1 Stack (isolated)
Thread 2 ржПрж░ data тЖТ Thread 2 Stack (isolated)

ржХрзЛржи data race condition ржирзЗржЗ!
```

### тЬЕ 2. Independent Execution
```
Thread 1: Deep recursion ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ (stack growing)
Thread 2: Simple function ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ (small stack)

ржПржХржЬржи ржЕржирзНржпржЬржиржХрзЗ ржкрзНрж░ржнрж╛ржмрж┐ржд ржХрж░рзЗ ржирж╛!
```

### тЬЕ 3. Easy Debugging
```
Thread crash рж╣рж▓рзЗ:
- рж╢рзБржзрзБ рж╕рзЗржЗ thread ржПрж░ stack ржжрзЗржЦрж▓рзЗржЗ рж╣ржмрзЗ
- ржЕржирзНржп threads ржПрж░ stack unaffected
```

### тЬЕ 4. Context Switching
```
OS ржпржЦржи thread switch ржХрж░рзЗ:
- Current thread ржПрж░ stack pointer save ржХрж░рзЗ
- Next thread ржПрж░ stack pointer load ржХрж░рзЗ
- ржкрзНрж░рждрж┐ржЯрж┐ thread ржирж┐ржЬрзЗрж░ stack ржП ржлрж┐рж░рзЗ ржЖрж╕рзЗ
```

---

## CPU Register ржПржмржВ Stack Pointer

ржкрзНрж░рждрж┐ржЯрж┐ thread ржПрж░ ржЬржирзНржп CPU maintain ржХрж░рзЗ:

```
Thread 1:                    Thread 2:
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ SP (Stack Ptr)   тФВтФАтФАтФАтЖТ    тФВ SP (Stack Ptr)   тФВтФАтФАтФАтЖТ
тФВ Points to:       тФВ        тФВ Points to:       тФВ
тФВ 0x1000           тФВ        тФВ 0x3000           тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ        тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
       тФВ                           тФВ
       тЖУ                           тЖУ
Thread 1 Stack             Thread 2 Stack
```

**SP (Stack Pointer)** = ржПржХржЯрж╛ special register ржпрж╛ ржмрж▓рзЗ "ржПржЦржи stack ржПрж░ ржХрзЛржерж╛ржпрж╝ ржЖржЫрж┐"

---

## ржХрзЗржи ржкрзНрж░рждрж┐ржЯрж┐ Thread ржПрж░ ржЖрж▓рж╛ржжрж╛ Stack рж▓рж╛ржЧрзЗ?

ржоржирзЗ ржХрж░рзБржи ржжрзБржЗржЯрж╛ thread ржПржХрж╕рж╛ржерзЗ ржХрж╛ржЬ ржХрж░ржЫрзЗ:

**ржпржжрж┐ ржПржХржЯрж╛ржЗ Stack ржерж╛ржХрзЗ (рж╕ржорж╕рзНржпрж╛ рж╣ржмрзЗ):**
```
Thread 1: functionA() ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ
Thread 2: functionB() ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ

ржПржХржЗ Stack ржП ржжрзБржЗржЯрж╛ function ржПрж░ data ржорж┐рж╢рзЗ ржпрж╛ржмрзЗ!
тЖТ Program crash ржХрж░ржмрзЗ
```

**ржЖрж▓рж╛ржжрж╛ Stack ржерж╛ржХрж▓рзЗ (ржирж┐рж░рж╛ржкржж):**
```
Thread 1 Stack:      Thread 2 Stack:
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР     тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ functionA() тФВ     тФВ functionB() тФВ
тФВ   data      тФВ     тФВ   data      тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ     тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

ржХрзЛржи conflict ржирзЗржЗ! тЬУ
```

---

## Go рждрзЗ Goroutine ржПржмржВ Stack

### Goroutine ржХрзА?
Goroutine = Go ржПрж░ lightweight thread (рж╣рж╛рж▓ржХрж╛ thread)

### Stack Size рждрзБрж▓ржирж╛:

**Traditional OS Thread:**
- рж╢рзБрж░рзБрждрзЗржЗ 1-2 MB stack ржмрж░рж╛ржжрзНржж
- Fixed size (ржкрж░рж┐ржмрж░рзНрждржи рж╣ржпрж╝ ржирж╛)
- 1000 thread = 1-2 GB memory!

**Go Goroutine:**
- рж╢рзБрж░рзБрждрзЗ ржорж╛рждрзНрж░ 2 KB stack
- ржкрзНрж░ржпрж╝рзЛржЬржи ржорждрзЛ ржмрж╛ржбрж╝рзЗ (maximum 1 GB)
- 1000 goroutine = ржорж╛рждрзНрж░ 2 MB memory!

```
OS Thread Stack:  [тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ] 1 MB (fixed)
Goroutine Stack:  [тЦИ] 2 KB тЖТ ржмрж╛ржбрж╝рзЗ ржкрзНрж░ржпрж╝рзЛржЬржи ржорждрзЛ
```

---

## Memory Layout (рж╕рж╣ржЬржнрж╛ржмрзЗ)

```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ        Kernel Space            тФВ  тЖР OS ржПрж░ ржЬржирзНржп
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ                                тФВ
тФВ   Goroutine 3 Stack [тЦИтЦИ]       тФВ
тФВ   Goroutine 2 Stack [тЦИтЦИтЦИ]      тФВ  тЖР ржкрзНрж░рждрж┐ржЯрж┐рж░ ржЖрж▓рж╛ржжрж╛ stack
тФВ   Goroutine 1 Stack [тЦИтЦИ]       тФВ
тФВ                                тФВ
тФВ   тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА     тФВ
тФВ                                тФВ
тФВ   Heap (Shared Memory)         тФВ  тЖР рж╕ржмрж╛ржЗ share ржХрж░рзЗ
тФВ                                тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ   Global Variables             тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ   Program Code                 тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

---

## Process, OS ржПржмржВ Kernel ржПрж░ ржнрзВржорж┐ржХрж╛

### 1. Process Level (ржкрзНрж░рзЛржЧрзНрж░рж╛ржо рж▓рзЗржнрзЗрж▓)

**Process = ржПржХржЯрж╛ ржЪрж▓ржорж╛ржи program**

```
Go Program (Process)
тФВ
тФЬтФА Goroutine 1 (ржирж┐ржЬрж╕рзНржм stack)
тФЬтФА Goroutine 2 (ржирж┐ржЬрж╕рзНржм stack)
тФЬтФА Goroutine 3 (ржирж┐ржЬрж╕рзНржм stack)
тФФтФА Shared Heap memory
```

### 2. Operating System Level

OS ржПрж░ ржХрж╛ржЬ:
- **Memory ржжрзЗржУржпрж╝рж╛**: Virtual memory provide ржХрж░рзЗ
- **Thread Management**: Underlying threads manage ржХрж░рзЗ
- **Scheduling**: ржХрзЛржи thread CPU ржкрж╛ржмрзЗ decide ржХрж░рзЗ

**Go ржПрж░ ржмрж┐рж╢рзЗрж╖рждрзНржм:**
```
10,000 Goroutines
       тЖУ
Go Runtime (ржирж┐ржЬрзЗржЗ manage ржХрж░рзЗ)
       тЖУ
4-8 OS Threads (CPU core ржЕржирзБржпрж╛ржпрж╝рзА)
       тЖУ
Operating System
```

Go runtime ржирж┐ржЬрзЗржЗ goroutine ржЧрзБрж▓рзЛ schedule ржХрж░рзЗ, OS ржХрзЗ рж▓рж╛ржЧрзЗ ржирж╛!

### 3. Kernel Level

Kernel ржПрж░ ржХрж╛ржЬ:
- **Physical Memory ржжрзЗржУржпрж╝рж╛**: RAM allocate ржХрж░рзЗ
- **CPU Time ржжрзЗржУржпрж╝рж╛**: ржХрзЛржи process ржХржЦржи CPU ржкрж╛ржмрзЗ
- **System Resources**: File, Network ржЗрждрзНржпрж╛ржжрж┐ manage ржХрж░рзЗ

```
User Space:    [Go Program + Goroutines]
                        тЖХ
              System Call Interface
                        тЖХ
Kernel Space:  [Memory + CPU + I/O Manager]
```

---

## M:N Threading Model (Go ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ)

ржПржЯрж╛ Go ржПрж░ magic!

```
M Goroutines (ржЕржирзЗржХ, ржпрзЗржоржи 10,000)
      тЖУ
Go Runtime Scheduler (middleman)
      тЖУ
N OS Threads (ржХржо, ржпрзЗржоржи 4-8)
      тЖУ
CPU Cores
```

**рж╕рзБржмрж┐ржзрж╛:**
- ржЕржирзЗржХ goroutine ржХрж┐ржирзНрждрзБ ржХржо OS thread
- ржЦрзБржм efficient
- ржХржо memory ржмрзНржпржмрж╣рж╛рж░

---

## Code Example - ржмрж╛рж╕рзНрждржм ржЙржжрж╛рж╣рж░ржг

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

func worker(id int) {
    // ржПржЗ variable worker ржПрж░ ржирж┐ржЬрж╕рзНржм stack ржП ржерж╛ржХржмрзЗ
    name := fmt.Sprintf("Worker-%d", id)
    
    fmt.Printf("%s started\n", name)
    time.Sleep(1 * time.Second)
    fmt.Printf("%s finished\n", name)
}

func main() {
    fmt.Printf("CPU Cores: %d\n", runtime.NumCPU())
    
    // 5ржЯрж┐ goroutine рждрзИрж░рж┐ ржХрж░рж┐
    // ржкрзНрж░рждрж┐ржЯрж┐рж░ ржЖрж▓рж╛ржжрж╛ stack ржерж╛ржХржмрзЗ
    for i := 1; i <= 5; i++ {
        go worker(i)
    }
    
    // Main goroutine wait ржХрж░рзЗ
    time.Sleep(2 * time.Second)
    
    fmt.Printf("Active Goroutines: %d\n", runtime.NumGoroutine())
}
```

**Output:**
```
CPU Cores: 4
Worker-1 started
Worker-2 started
Worker-3 started
Worker-4 started
Worker-5 started
Worker-1 finished
Worker-2 finished
Worker-3 finished
Worker-4 finished
Worker-5 finished
Active Goroutines: 1
```

---

## Stack ржХрзАржнрж╛ржмрзЗ Grow ржХрж░рзЗ?

```
рж╢рзБрж░рзБрждрзЗ:
Goroutine Stack: [тЦИтЦИ] 2 KB

Deep recursion ржмрж╛ ржмрзЗрж╢рж┐ local variable:
Goroutine Stack: [тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ] 16 KB

ржЖрж░ржУ ржкрзНрж░ржпрж╝рзЛржЬржи рж╣рж▓рзЗ:
Goroutine Stack: [тЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИтЦИ] 64 KB

Maximum:
Goroutine Stack: [тЦИтЦИтЦИтЦИ...тЦИтЦИтЦИтЦИ] 1 GB
```

Go runtime automatically stack grow ржХрж░рзЗ - ржЖржкржирж╛ржХрзЗ ржЪрж┐ржирзНрждрж╛ ржХрж░рждрзЗ рж╣ржмрзЗ ржирж╛!

---

## рж╕рж╛рж░рж╕ржВржХрзНрж╖рзЗржк - ржорзВрж▓ ржкржпрж╝рзЗржирзНржЯ

### 1. Stack Separation (ржЖрж▓рж╛ржжрж╛ Stack)
- ржкрзНрж░рждрж┐ржЯрж┐ goroutine = ржЖрж▓рж╛ржжрж╛ stack
- ржХрзЛржи conflict ржирзЗржЗ
- Thread safe execution

### 2. Efficient Memory Usage
- рж╢рзБрж░рзБрждрзЗ ржорж╛рждрзНрж░ 2 KB
- ржкрзНрж░ржпрж╝рзЛржЬржи ржорждрзЛ ржмрж╛ржбрж╝рзЗ
- рж▓рж╛ржЦрзЛ goroutine рж╕ржорзНржнржм

### 3. Three Layers
```
Process Level:  Go program ржЪрж▓рзЗ
       тЖУ
OS Level:       Memory ржПржмржВ threads manage
       тЖУ
Kernel Level:   Physical resources provide
```

### 4. Go Runtime ржПрж░ ржнрзВржорж┐ржХрж╛
- Goroutine scheduling ржирж┐ржЬрзЗржЗ ржХрж░рзЗ
- Stack management automatic
- OS ржерзЗржХрзЗ independent

---

## ржХрзЗржи ржПржЯрж╛ Important?

### Traditional Way (OS Threads):
```
100 threads = 100-200 MB memory
Context switching slow
Limited scalability
```

### Go Way (Goroutines):
```
100,000 goroutines = 200 MB memory
Fast switching
Highly scalable
Easy to write concurrent code
```

---

## Final Diagram - ржкрзБрж░рзЛ Picture

```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ         ржЖржкржирж╛рж░ Go Program                тФВ
тФВ  тФМтФАтФАтФАтФАтФАтФР  тФМтФАтФАтФАтФАтФАтФР  тФМтФАтФАтФАтФАтФАтФР  тФМтФАтФАтФАтФАтФАтФР   тФВ
тФВ  тФВ G1  тФВ  тФВ G2  тФВ  тФВ G3  тФВ  тФВ G4  тФВ   тФВ тЖР Goroutines
тФВ  тФФтФАтФАтФмтФАтФАтФШ  тФФтФАтФАтФмтФАтФАтФШ  тФФтФАтФАтФмтФАтФАтФШ  тФФтФАтФАтФмтФАтФАтФШ   тФВ   (ржирж┐ржЬрж╕рзНржм stack)
тФВ     тФФтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФШ       тФВ
тФВ              Go Runtime                 тФВ
тФВ     тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР           тФВ
тФВ  тФМтФАтФАтФ┤тФАтФАтФР  тФМтФАтФАтФ┤тФАтФАтФР  тФМтФАтФАтФ┤тФАтФАтФР           тФВ тЖР OS Threads
тФВ  тФВ T1  тФВ  тФВ T2  тФВ  тФВ T3  тФВ           тФВ   (ржХржо рж╕ржВржЦрзНржпржХ)
тФФтФАтФАтФ┤тФАтФАтФАтФАтФАтФ┤тФАтФАтФ┤тФАтФАтФАтФАтФАтФ┤тФАтФАтФ┤тФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
       тФВ        тФВ        тФВ
тФМтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ      Operating System (Linux/Mac)      тФВ
тФВ         - Memory Management            тФВ
тФВ         - Thread Scheduling            тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
                 тФВ
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ           Kernel                        тФВ
тФВ    - Physical Memory (RAM)             тФВ
тФВ    - CPU Management                    тФВ
тФВ    - Hardware Resources                тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

---

## Thread Stack ржПрж░ Lifecycle

### Stack рждрзИрж░рж┐ рж╣ржУржпрж╝рж╛ ржерзЗржХрзЗ рж╢рзЗрж╖ рж╣ржУржпрж╝рж╛:

```
1. Thread/Goroutine рждрзИрж░рж┐:
   тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
   тФВ OS/Runtime ржирждрзБржи     тФВ
   тФВ Stack allocate ржХрж░рзЗ  тФВ тЖТ 2KB (Go) ржмрж╛ 1MB (OS thread)
   тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

2. Function Execution:
   тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
   тФВ Function call рж╣рж▓рзЗ   тФВ
   тФВ Stack grow ржХрж░рзЗ      тФВ тЖТ Push data
   тФВ Return рж╣рж▓рзЗ shrink   тФВ тЖТ Pop data
   тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

3. Stack Overflow Check:
   тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
   тФВ Stack ржкрзВрж░рзНржг рж╣рж▓рзЗ?    тФВ
   тФВ - Go: Automatically тФВ тЖТ ржирждрзБржи ржмржбрж╝ stack рждрзИрж░рж┐
   тФВ       grow ржХрж░рзЗ      тФВ   + data copy ржХрж░рзЗ
   тФВ - OS: Crash! ЁЯТе     тФВ
   тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

4. Thread рж╢рзЗрж╖:
   тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
   тФВ Thread terminate    тФВ
   тФВ Stack memory free   тФВ тЖТ Memory ржлрзЗрж░ржд ржжрзЗржпрж╝
   тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

---

## Stack vs Heap - ржкрж╛рж░рзНржержХрзНржп

ржЕржирзЗржХрзЗ Stack ржЖрж░ Heap confuse ржХрж░рзЗред ржкрж╛рж░рзНржержХрзНржп ржЬрж╛ржирж╛ ржЬрж░рзБрж░рж┐:

```
STACK (ржкрзНрж░рждрж┐ржЯрж┐ thread ржПрж░ ржЖрж▓рж╛ржжрж╛):
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ тЬУ Local variables           тФВ
тФВ тЬУ Function parameters       тФВ
тФВ тЬУ Return addresses          тФВ
тФВ тЬУ Fast allocation           тФВ
тФВ тЬУ Automatic cleanup         тФВ
тФВ тЬУ Limited size              тФВ
тФВ тЬЧ Thread ржПрж░ ржмрж╛ржЗрж░рзЗ access ржирзЗржЗтФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ

HEAP (рж╕ржм threads share ржХрж░рзЗ):
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ тЬУ Dynamic allocations       тФВ
тФВ тЬУ Objects, Arrays           тФВ
тФВ тЬУ рж╕ржм threads access ржХрж░рждрзЗ ржкрж╛рж░рзЗтФВ
тФВ тЬУ Large size                тФВ
тФВ тЬЧ Slower allocation         тФВ
тФВ тЬЧ Manual/GC cleanup         тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

**Example:**
```go
func example() {
    // STACK ржП (local variable)
    x := 10
    
    // HEAP ржП (dynamic allocation)
    slice := make([]int, 1000)
    
    // Stack ржП pointer, data Heap ржП
    ptr := new(int)
}
```

---

## Common Pitfalls (рж╕рж╛ржзрж╛рж░ржг ржнрзБрж▓)

### тЭМ 1. Stack Overflow

```go
// Infinite recursion
func recursive() {
    recursive() // Stack overflow!
}

// ржкрзНрж░рждрж┐ржЯрж┐ call ржП stack grow ржХрж░рждрзЗ ржерж╛ржХржмрзЗ
// рж╢рзЗрж╖рзЗ memory рж╢рзЗрж╖ тЖТ Crash!
```

### тЭМ 2. Returning Pointer to Local Variable (C/C++)

```c
// C/C++ ржП ржнрзБрж▓ (Go рждрзЗ problem ржирзЗржЗ)
int* getNumber() {
    int x = 10;  // Stack ржП
    return &x;   // Stack address return ржХрж░ржЫрзЗ!
}
// Function рж╢рзЗрж╖ рж╣рж▓рзЗ stack cleanup
// Pointer invalid рж╣ржпрж╝рзЗ ржпрж╛ржмрзЗ! ЁЯТе
```

**Go рждрзЗ ржПржЗ рж╕ржорж╕рзНржпрж╛ ржирзЗржЗ:**
```go
func getNumber() *int {
    x := 10  // Compiler heap ржП рж░рж╛ржЦржмрзЗ
    return &x // Safe! тЬУ
}
// Go compiler automatically heap ржП allocate ржХрж░рзЗ
```

### тЭМ 3. Large Local Arrays

```go
func processData() {
    // 1 GB array stack ржП?
    var huge [1000000000]int // Stack overflow!
    
    // Better: Heap ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи
    huge := make([]int, 1000000000) // тЬУ
}
```

---

## Performance Implications

### Stack Operations (ржЦрзБржм ржжрзНрж░рзБржд):
```
Push to Stack:  1-2 CPU cycles
Pop from Stack: 1-2 CPU cycles
Stack Allocation: рж╕рж╛ржзрж╛рж░ржгржд free!

ржХрж╛рж░ржг: Stack pointer рж╢рзБржзрзБ move рж╣ржпрж╝
```

### Heap Operations (рждрзБрж▓ржирж╛ржорзВрж▓ржХ ржзрзАрж░):
```
Heap Allocation:  ~100+ CPU cycles
Heap Deallocation: GC overhead
Memory fragmentation: рж╕ржорзНржнржм

ржХрж╛рж░ржг: Complex memory management
```

**ржПржЗ ржЬржирзНржпржЗ Go рждрзЗ:**
- ржЫрзЛржЯ objects тЖТ Stack ржП рж░рж╛ржЦрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛
- ржмржбрж╝ objects ржмрж╛ shared data тЖТ Heap ржП

---

## Practical Debugging Tips

### 1. Stack Trace ржжрзЗржЦрж╛:

```go
package main

import (
    "fmt"
    "runtime/debug"
)

func functionC() {
    // Stack trace print ржХрж░рж┐
    debug.PrintStack()
}

func functionB() {
    functionC()
}

func functionA() {
    functionB()
}

func main() {
    functionA()
}
```

**Output:**
```
goroutine 1 [running]:
runtime/debug.Stack()
main.functionC()
    /path/file.go:10
main.functionB()
    /path/file.go:14
main.functionA()
    /path/file.go:18
main.main()
    /path/file.go:22

ржкрзНрж░рждрж┐ржЯрж┐ function ржПрж░ stack frame ржжрзЗржЦрж╛ ржпрж╛ржЪрзНржЫрзЗ!
```

### 2. Stack Size Monitor:

```go
import "runtime"

func checkStack() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    fmt.Printf("Stack in use: %d KB\n", m.StackInuse/1024)
    fmt.Printf("Stack from OS: %d KB\n", m.StackSys/1024)
}
```

---

## ржоржирзЗ рж░рж╛ржЦрж╛рж░ рж╕рж╣ржЬ Tips

### ЁЯОп ржорзВрж▓ Concepts:

1. **Separate Stack = Thread Safety**
    - ржкрзНрж░рждрж┐ржЯрж┐ thread ржПрж░ ржирж┐ржЬрж╕рзНржм workspace
    - ржХрзЛржи data mixing ржирзЗржЗ

2. **Stack = Fast but Limited**
    - ржЦрзБржм ржжрзНрж░рзБржд allocation/deallocation
    - ржХрж┐ржирзНрждрзБ size limited

3. **Heap = Shared but Slower**
    - рж╕ржм threads access ржХрж░рждрзЗ ржкрж╛рж░рзЗ
    - ржзрзАрж░ ржХрж┐ржирзНрждрзБ flexible

4. **Go = Smart Stack Management**
    - Automatic growth
    - Escape analysis (stack vs heap decision)
    - Efficient goroutine stacks

### ЁЯУК Quick Comparison:

```
Traditional Threading:
- Heavy threads (1-2 MB each)
- OS manages everything
- Limited scalability (1000s)

Go Goroutines:
- Light threads (2 KB start)
- Go runtime manages
- Massive scalability (millions)

The Secret: Separate, efficient stacks! тЬи
```

ржПржЗ ржкрзБрж░рзЛ system ржПржХрж╕рж╛ржерзЗ ржХрж╛ржЬ ржХрж░рзЗ ржЖржкржирж╛рж░ concurrent program efficient ржнрж╛ржмрзЗ ржЪрж╛рж▓рж╛рждрзЗ! ЁЯЪА

---

## References & Further Reading

- **Go Official Docs**: https://go.dev/doc/
- **Go Memory Model**: https://go.dev/ref/mem
- **Stack vs Heap**: Computer Science fundamentals
- **Goroutine Internals**: Go runtime source code