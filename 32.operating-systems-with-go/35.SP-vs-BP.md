# Go-তে Stack Pointer (SP) ও Base Pointer (BP) - বিস্তারিত ব্যাখ্যা

## মেমরি সেগমেন্ট সমূহ

একটি Go প্রোগ্রাম চালানোর সময় মেমরিকে চারটি প্রধান অংশে ভাগ করা হয়:

### 1. **Code Segment (Text Segment)**
- প্রোগ্রামের সকল কম্পাইল করা কোড/instruction এখানে থাকে
- Read-only মেমরি (পরিবর্তন করা যায় না)
- `main()` এবং `addSum()` ফাংশনের মেশিন কোড এখানে সংরক্ষিত

### 2. **Data Segment**
- Global variables এবং static data সংরক্ষিত হয়
- initialized এবং uninitialized data এর জন্য আলাদা সেকশন
- উদাহরণ: package-level variables

### 3. **Stack Segment**
- Function calls, local variables, return addresses সংরক্ষিত হয়
- LIFO (Last In First Out) পদ্ধতিতে কাজ করে
- প্রতিটি function call এ একটি **stack frame** তৈরি হয়
- Stack নিচ থেকে উপরে বৃদ্ধি পায় (high address → low address)

### 4. **Heap Segment**
- Dynamic memory allocation এর জন্য ব্যবহৃত
- `new()` বা `make()` দিয়ে যা তৈরি করা হয়
- Garbage collector এটি পরিচালনা করে

---

## Stack Pointer (SP) এবং Base Pointer (BP)

### **Stack Pointer (SP)**
- Stack এর **বর্তমান top** নির্দেশ করে
- প্রতিটি push/pop operation এ SP পরিবর্তন হয়
- নতুন data যোগ হলে SP কমে (নিচের দিকে)
- Go-তে: hardware register দ্বারা maintain করা হয়

### **Base Pointer (BP) / Frame Pointer (FP)**
- Current function এর stack frame এর **শুরু** নির্দেশ করে
- Function execution এর সময় এটি স্থির থাকে
- Local variables এবং parameters খুঁজে পেতে reference point হিসেবে কাজ করে
- Go-তে: সাধারণত implicit, compiler এটি ম্যানেজ করে

---

## উদাহরণ কোড বিশ্লেষণ

```go
package main

import "fmt"

func addSum(x int, y int) int {
    res := x + y
    return res
}

func main() {
    var a int = 200
    var sum = addSum(a, 10)
    fmt.Println(sum)
}
```

---

## Step-by-Step Stack Frame এর কার্যপ্রণালী

### **Step 1: প্রোগ্রাম শুরু**

```
Memory Layout:
┌─────────────────┐ ← High Address
│   Code Segment  │ (main, addSum এর মেশিন কোড)
├─────────────────┤
│  Data Segment   │ (global variables)
├─────────────────┤
│      Heap       │ (dynamic allocation)
├─────────────────┤
│     Stack       │ ← SP (Stack Top)
└─────────────────┘ ← Low Address
```

### **Step 2: main() ফাংশন শুরু**

```
Stack:
┌──────────────────┐ ← BP (main এর Frame Pointer)
│  Return Address  │ (OS এ ফিরে যাওয়ার address)
├──────────────────┤
│   a = 200        │ (local variable)
├──────────────────┤ ← SP (Stack Pointer)
└──────────────────┘

- BP: main এর stack frame এর base নির্দেশ করে
- SP: বর্তমান stack এর top নির্দেশ করে
- Variable 'a' stack এ সংরক্ষিত (value: 200)
```

### **Step 3: addSum(a, 10) Call করা হলে**

```
Stack:
┌──────────────────┐ 
│  Return Address  │ (OS)
├──────────────────┤ ← main এর BP
│   a = 200        │
├──────────────────┤
│  Return Address  │ (main এ ফিরে আসার address)
├──────────────────┤
│   y = 10         │ (parameter)
├──────────────────┤
│   x = 200        │ (parameter)
├──────────────────┤ ← addSum এর BP
│   res = 210      │ (local variable)
├──────────────────┤ ← SP (বর্তমান top)
└──────────────────┘

নতুন Stack Frame তৈরি হয়েছে:
- addSum এর জন্য নতুন BP set করা হয়
- Parameters (x, y) push করা হয়
- Return address সংরক্ষিত হয়
- Local variable 'res' জন্য জায়গা বরাদ্দ
- SP নিচের দিকে সরে যায়
```

### **Step 4: addSum() থেকে Return**

```
Stack:
┌──────────────────┐
│  Return Address  │ (OS)
├──────────────────┤ ← main এর BP
│   a = 200        │
├──────────────────┤
│   sum = 210      │ (return value সংরক্ষিত)
├──────────────────┤ ← SP
└──────────────────┘

- addSum এর stack frame মুছে যায়
- Return value (210) sum variable এ সংরক্ষিত
- BP পুনরায় main এর frame নির্দেশ করে
- SP উপরে উঠে যায়
```

---

## Stack Frame এর গঠন (বিস্তারিত)

```
একটি Stack Frame এ থাকে:

┌─────────────────────┐ ← Previous BP
│  Return Address     │ (caller এ ফিরে যাওয়ার address)
├─────────────────────┤
│  Function Arguments │ (parameters: x, y)
├─────────────────────┤ ← Current BP
│  Local Variables    │ (res)
├─────────────────────┤
│  Temporary Values   │ (computation এর জন্য)
├─────────────────────┤ ← SP
└─────────────────────┘
```

---

## Go-তে বিশেষত্ব

### **1. Stack Growth**
- Go-তে stack dynamically বৃদ্ধি পায়
- প্রয়োজন হলে স্বয়ংক্রিয়ভাবে বড় হয়
- অন্যান্য ভাষার মতো fixed size নয়

### **2. Escape Analysis**
- Compiler সিদ্ধান্ত নেয় কোন variable stack এ থাকবে, কোনটি heap এ
- যদি variable function এর বাইরে access করা হয়, তাহলে heap এ allocate হয়

```go
func example() *int {
    x := 10  // এটি heap এ যাবে কারণ pointer return করা হচ্ছে
    return &x
}
```

### **3. Goroutine এর নিজস্ব Stack**
- প্রতিটি goroutine এর আলাদা stack আছে
- শুরুতে ছোট (2KB), প্রয়োজনে বৃদ্ধি পায়

---

## Assembly Level এ দেখা (সরলীকৃত)

```assembly
main:
    SUBQ    $16, SP        ; Stack এ 16 bytes জায়গা তৈরি
    MOVQ    $200, 8(SP)    ; a = 200 সংরক্ষণ
    MOVQ    $200, 0(SP)    ; x parameter
    MOVQ    $10, 8(SP)     ; y parameter
    CALL    addSum         ; addSum call
    
addSum:
    MOVQ    16(SP), AX     ; x load করা
    ADDQ    24(SP), AX     ; y যোগ করা
    MOVQ    AX, ~r2+32(SP) ; result return
    RET                    ; main এ ফিরে যাওয়া
```

---

## মূল পার্থক্য: SP vs BP

| বৈশিষ্ট্য | Stack Pointer (SP) | Base Pointer (BP) |
|---------|-------------------|-------------------|
| **কাজ** | Stack এর বর্তমান top নির্দেশ করে | Function frame এর base নির্দেশ করে |
| **পরিবর্তন** | প্রতিটি push/pop এ পরিবর্তন হয় | Function execution এর সময় স্থির থাকে |
| **উদ্দেশ্য** | Stack operation track করা | Local variables access করা |
| **Direction** | Grows downward (high → low) | Fixed reference point |

---

## সারসংক্ষেপ

1. **Code Segment** = প্রোগ্রামের executable code
2. **Data Segment** = Global/static variables
3. **Stack** = Function calls, local variables (SP/BP দিয়ে পরিচালিত)
4. **Heap** = Dynamic memory allocation

**Stack Frame** প্রতিটি function call এ তৈরি হয়, যেখানে:
- **BP**: Frame এর শুরু নির্দেশ করে (reference point)
- **SP**: বর্তমান stack top নির্দেশ করে (dynamic)

Go-তে এই সব কিছু compiler এবং runtime স্বয়ংক্রিয়ভাবে পরিচালনা করে, যা memory management সহজ করে তোলে।

---

## আরও জানতে
- Go Assembly: `go tool compile -S file.go`
- Escape Analysis: `go build -gcflags="-m" file.go`
- Stack trace: `runtime.Stack()` ব্যবহার করুন