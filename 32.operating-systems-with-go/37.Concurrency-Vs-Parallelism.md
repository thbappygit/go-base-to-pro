# Concurrency vs Parallelism - CPU এবং Golang এ

## মূল পার্থক্য

### Concurrency (সমসাময়িকতা)
**সংজ্ঞা:** একাধিক কাজ একই সময়ে পরিচালনা করা, কিন্তু একসাথে execute না হওয়া।

**উদাহরণ:** একজন শেফ একাই রান্নাঘরে একসাথে বিভিন্ন খাবার রান্না করছেন - এক খাবারে নাড়া দিচ্ছেন, তারপর অন্য খাবার কাটছেন, আবার প্রথম খাবার চেক করছেন। সব কাজ একসাথে হচ্ছে বলে মনে হলেও তিনি একসময় একটাই কাজ করছেন।

**বৈশিষ্ট্য:**
- একটি CPU core এও implement করা সম্ভব
- Time slicing ব্যবহার করে tasks এর মধ্যে switch করা হয়
- Structure এবং composition নিয়ে বেশি চিন্তা করতে হয়

### Parallelism (সমান্তরালতা)
**সংজ্ঞা:** একাধিক কাজ ঠিক একই মুহূর্তে বিভিন্ন processor/core এ execute হওয়া।

**উদাহরণ:** তিনজন শেফ তিনটি আলাদা রান্নাঘরে একসাথে তিনটি ভিন্ন খাবার রান্না করছেন। সব কাজ literally একই সময়ে হচ্ছে।

**বৈশিষ্ট্য:**
- একাধিক CPU core প্রয়োজন
- Actual simultaneous execution
- Performance এবং speed বৃদ্ধি

## CPU তে কীভাবে কাজ করে

### Single Core CPU
```
Timeline: ---[Task A]--[Task B]--[Task A]--[Task C]--[Task B]---
```
- শুধুমাত্র concurrency সম্ভব
- Context switching এর মাধ্যমে tasks এর মধ্যে পরিবর্তন
- Parallelism সম্ভব নয়

### Multi-Core CPU
```
Core 1: ---[Task A]----------[Task A]----------[Task A]---
Core 2: ---[Task B]----------[Task B]----------[Task B]---
Core 3: ---[Task C]----------[Task C]----------[Task C]---
```
- Concurrency এবং parallelism দুটোই সম্ভব
- একসাথে একাধিক tasks execute হতে পারে

## Golang এ Concurrency এবং Parallelism

### Goroutines (Concurrency এর জন্য)

Goroutines হলো lightweight threads যা Go runtime manage করে।

```go
package main

import (
    "fmt"
    "time"
)

func task(name string) {
    for i := 1; i <= 3; i++ {
        fmt.Printf("%s: %d\n", name, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // Concurrent execution
    go task("Task A")
    go task("Task B")
    go task("Task C")
    
    // Main goroutine wait করার জন্য
    time.Sleep(time.Second)
}
```

**বৈশিষ্ট্য:**
- প্রতিটি goroutine মাত্র 2KB memory দিয়ে শুরু হয়
- লক্ষ লক্ষ goroutines একসাথে চালানো সম্ভব
- Go scheduler automatically manage করে

### Channels (Communication এর জন্য)

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("Worker %d started job %d\n", id, job)
        time.Sleep(time.Second)
        results <- job * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // 3টি concurrent workers
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // 5টি jobs পাঠানো
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)
    
    // Results collect করা
    for a := 1; a <= 5; a++ {
        <-results
    }
}
```

### GOMAXPROCS (Parallelism control করার জন্য)

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

func main() {
    // CPU cores এর সংখ্যা দেখা
    fmt.Println("CPU Cores:", runtime.NumCPU())
    
    // Parallel execution এর জন্য cores set করা
    runtime.GOMAXPROCS(4) // 4টি cores ব্যবহার করবে
    
    var wg sync.WaitGroup
    
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go func(n int) {
            defer wg.Done()
            // Heavy computation
            sum := 0
            for j := 0; j < 1000000; j++ {
                sum += j
            }
            fmt.Printf("Goroutine %d done\n", n)
        }(i)
    }
    
    wg.Wait()
}
```

## WaitGroup দিয়ে Synchronization

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Function শেষে automatically Done() call হবে
    
    fmt.Printf("Worker %d starting\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d done\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 5; i++ {
        wg.Add(1) // Counter বাড়ানো
        go worker(i, &wg)
    }
    
    wg.Wait() // সব goroutines শেষ হওয়া পর্যন্ত wait করা
    fmt.Println("All workers completed")
}
```

## Race Condition এবং Mutex

```go
package main

import (
    "fmt"
    "sync"
)

type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()         // Lock করা
    c.count++
    c.mu.Unlock()       // Unlock করা
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}

func main() {
    counter := SafeCounter{}
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Println("Final Count:", counter.Value())
}
```

## Interview এর জন্য Key Points

### Concurrency কখন ব্যবহার করবেন?
- I/O bound tasks (database queries, API calls, file operations)
- User interactions handle করা
- Multiple tasks manage করতে হলে যেগুলো waiting করে

### Parallelism কখন ব্যবহার করবেন?
- CPU intensive tasks (image processing, data crunching, calculations)
- Large datasets process করা
- Performance critical operations

### Golang এর সুবিধা
- Goroutines অত্যন্ত lightweight (OS threads এর তুলনায়)
- Built-in concurrency primitives (channels, select)
- CSP (Communicating Sequential Processes) model follow করে
- "Don't communicate by sharing memory; share memory by communicating"

### Common Patterns

**Worker Pool Pattern:**
```go
// একাধিক workers যারা একটি job queue থেকে কাজ নেয়
// Controlled parallelism এর জন্য ideal
```

**Fan-out/Fan-in Pattern:**
```go
// একটি task কে multiple goroutines এ ভাগ করা (fan-out)
// তারপর results একত্রিত করা (fan-in)
```

**Pipeline Pattern:**
```go
// Data processing stages যেখানে প্রতিটি stage একটি goroutine
// Channels দিয়ে stages connected
```

## সতর্কতা

1. **Goroutine leaks:** সবসময় নিশ্চিত করুন goroutines properly terminate হচ্ছে
2. **Deadlocks:** Channel operations এ সাবধান থাকুন
3. **Race conditions:** Shared memory access এ mutex ব্যবহার করুন
4. **Too many goroutines:** হাজার হাজার goroutines spawning করার আগে think করুন

## সারসংক্ষেপ

- **Concurrency = Structure:** একসাথে কাজ পরিচালনা করার design
- **Parallelism = Execution:** একসাথে কাজ সম্পাদন করা
- **Concurrency enables parallelism** কিন্তু এটা guarantee করে না
- Golang এ goroutines এবং channels দিয়ে concurrency সহজভাবে implement করা যায়
- GOMAXPROCS দিয়ে parallelism control করা যায় 