# Operating System: Process, Thread এবং Program Counter

## Process কি?

**Process** হলো একটি চলমান program। যখন আপনি কোনো application run করেন (যেমন: Music Player, Chrome Browser), তখন OS একটি process তৈরি করে।

### Process এর বৈশিষ্ট্য:
- প্রতিটি process এর আলাদা **memory space** থাকে
- Process গুলো একে অপরের memory তে সরাসরি access করতে পারে না
- প্রতিটি process এর নিজস্ব **resources** থাকে (CPU time, memory, file handlers)
- Process তৈরি করা **expensive** (সময় এবং resource বেশি লাগে)

### Process এর উপাদান:
1. **Code Section** - Program এর instructions
2. **Data Section** - Global variables
3. **Heap** - Dynamic memory allocation
4. **Stack** - Function calls, local variables
5. **Program Counter (PC)** - বর্তমানে কোন instruction execute হচ্ছে তার address

---

## Thread কি?

**Thread** হলো process এর ভিতরে একটি **lightweight execution unit**। একটি process এর মধ্যে একাধিক thread থাকতে পারে।

### Thread এর বৈশিষ্ট্য:
- সব thread একই process এর **memory space share** করে
- Thread তৈরি করা **lightweight** (কম সময় এবং resource লাগে)
- Thread গুলো একে অপরের data সহজেই access করতে পারে
- প্রতিটি thread এর নিজস্ব **stack** এবং **program counter** থাকে

### Thread এর উপাদান:
1. **Thread ID** - Unique identifier
2. **Program Counter** - বর্তমান instruction এর address
3. **Register Set** - Thread এর নিজস্ব register values
4. **Stack** - Function calls এবং local variables

---

## Program Counter (PC) কি?

**Program Counter** হলো একটি special register যা বর্তমানে কোন instruction execute হচ্ছে তার memory address রাখে।

### কিভাবে কাজ করে:
1. PC একটি instruction এর address point করে
2. CPU ঐ instruction fetch করে
3. Instruction execute হয়
4. PC পরবর্তী instruction এর address এ move করে
5. এভাবে চলতে থাকে

**উদাহরণ:**
```
Memory Address | Instruction
----------------------------
0x1000        | LOAD R1, 5
0x1004        | ADD R1, R2
0x1008        | STORE R1, X
0x100C        | JMP 0x1000

- শুরুতে PC = 0x1000
- LOAD execute হওয়ার পর PC = 0x1004
- ADD execute হওয়ার পর PC = 0x1008
- এভাবে চলতে থাকে
```

---

## উদাহরণ ১: Music Player Desktop App

### সিনারিও:
আপনি একটি music player app চালু করেছেন যা একসাথে:
- গান play করছে
- UI তে song information দেখাচ্ছে
- Playlist থেকে next song load করছে

### Process এবং Thread এর ব্যবহার:

```
Music Player Process (P1)
├── Main Thread (T1)
│   ├── PC: 0x5000 (UI rendering code)
│   └── Stack: UI event handlers
│
├── Audio Playback Thread (T2)
│   ├── PC: 0x6000 (audio decoding code)
│   └── Stack: Audio buffer management
│
├── File I/O Thread (T3)
│   ├── PC: 0x7000 (file reading code)
│   └── Stack: File operation data
│
└── Shared Memory:
    ├── Current Song Data
    ├── Playlist
    └── Audio Buffer
```

### বিস্তারিত ব্যাখ্যা:

**1. Main Thread (UI Thread):**
```
প্রথম অবস্থা:
PC = 0x5000 → renderUI()
- Button draw করছে
- Song name display করছে
- User input listen করছে

ব্যবহারকারী "Next" button এ click করলে:
PC = 0x5100 → handleNextButton()
- Playlist থেকে next song নির্বাচন
- Audio thread কে signal পাঠায়
```

**2. Audio Playback Thread:**
```
PC = 0x6000 → decodeAudio()
- Audio file থেকে data পড়ে
- Decode করে
- Speaker এ send করে

যখন buffer শেষ:
PC = 0x6200 → requestMoreData()
- File I/O thread কে signal দেয়
```

**3. File I/O Thread:**
```
PC = 0x7000 → readAudioFile()
- Disk থেকে audio data পড়ে
- Buffer এ রাখে
- Audio thread কে notify করে
```

### সুবিধা:
- **Responsive UI**: UI thread অন্য কাজে ব্যস্ত নয়, তাই app hang করে না
- **Smooth Playback**: Audio thread continuously audio process করতে পারে
- **Background Loading**: File I/O আলাদা thread এ হয় বলে main operation slow হয় না

### CPU Scheduling:
```
Time Slice 1: CPU → T1 (UI update)
Time Slice 2: CPU → T2 (Audio decode)
Time Slice 3: CPU → T3 (File read)
Time Slice 4: CPU → T1 (Handle user input)
...এভাবে rotate করতে থাকে
```

---

## উদাহরণ ২: Backend Server - Login Request এবং Database

### সিনারিও:
একজন user login করার চেষ্টা করছে। Server কে:
- Request receive করতে হবে
- Database query করতে হবে
- Response পাঠাতে হবে

### Traditional Single-Threaded Approach (খারাপ):

```
Server Process (P1)
└── Main Thread (T1)
    ├── PC: 0x8000 → receiveRequest()
    ├── PC: 0x8100 → queryDatabase() [BLOCKING - 500ms]
    └── PC: 0x8200 → sendResponse()

সমস্যা: Database query চলাকালীন নতুন request handle করতে পারে না!
User 2 এর request: ⏳ অপেক্ষা করতে হবে
User 3 এর request: ⏳ অপেক্ষা করতে হবে
```

### Multi-Threaded Approach (ভালো):

```
Server Process (P1)
├── Main Thread (T1) - Request Handler
│   └── PC: 0x8000 → listenForRequests()
│
├── Worker Thread 1 (T2) - User 1 এর login
│   ├── PC: 0x9000 → validateCredentials()
│   ├── PC: 0x9100 → queryDB("SELECT * FROM users WHERE...")
│   └── PC: 0x9200 → sendResponse()
│
├── Worker Thread 2 (T3) - User 2 এর login
│   ├── PC: 0x9000 → validateCredentials()
│   └── Waiting for DB...
│
└── Worker Thread 3 (T4) - User 3 এর request
    └── PC: 0x9050 → processRequest()
```

### Step-by-Step Flow:

**Step 1: Request আসে**
```
User 1: POST /login {username: "rahim", password: "****"}

Main Thread (T1):
PC = 0x8000 → acceptConnection()
PC = 0x8050 → createWorkerThread() → T2 তৈরি হয়
PC = 0x8000 → আবার listening এ ফিরে যায়
```

**Step 2: Worker Thread কাজ শুরু করে**
```
Worker Thread T2 (User 1 এর জন্য):
PC = 0x9000 → parseRequest()
  ├── Username extract করা
  └── Password extract করা

PC = 0x9050 → validateInput()
  ├── Username empty কিনা check
  └── Password length check

PC = 0x9100 → connectToDatabase()
  └── Database connection establish
```

**Step 3: Database Query (Blocking Operation)**
```
Worker Thread T2:
PC = 0x9150 → executeQuery()
  Query: "SELECT * FROM users WHERE username='rahim'"
  
  [এখানে thread wait করে, কিন্তু অন্য thread গুলো চলতে থাকে]
  
CPU এর Scheduling:
- T2: Waiting (I/O blocked)
- T1: Running (নতুন request receive করছে)
- T3: Running (অন্য user এর request handle করছে)
```

**Step 4: Database Response আসে**
```
Database থেকে data এসেছে:
{
  user_id: 123,
  username: "rahim",
  password_hash: "$2b$10$...",
  email: "rahim@example.com"
}

Worker Thread T2 আবার active:
PC = 0x9200 → comparePassword()
  ├── User এর দেওয়া password hash করা
  └── Database এর hash এর সাথে match করা

PC = 0x9250 → generateToken()
  └── JWT token তৈরি করা

PC = 0x9300 → sendResponse()
  Response: {success: true, token: "eyJhbGc..."}
```

### Go Language এ Implementation:

```go
package main

import (
    "database/sql"
    "net/http"
    "time"
)

// Main Thread: Server শুরু
func main() {
    // এটি main goroutine (thread)
    http.HandleFunc("/login", loginHandler)
    http.ListenAndServe(":8080", nil)
}

// প্রতিটি request এর জন্য নতুন goroutine (thread)
func loginHandler(w http.ResponseWriter, r *http.Request) {
    // এটি একটি নতুন goroutine তে run করে
    // প্রতিটি goroutine এর নিজস্ব PC এবং Stack আছে
    
    username := r.FormValue("username")
    password := r.FormValue("password")
    
    // Database query (blocking operation)
    // এই thread block হলেও অন্য thread গুলো চলতে থাকে
    user := queryDatabase(username)
    
    if validatePassword(user, password) {
        token := generateToken(user)
        w.Write([]byte(`{"token": "` + token + `"}`))
    } else {
        w.WriteHeader(401)
        w.Write([]byte(`{"error": "Invalid credentials"}`))
    }
}

func queryDatabase(username string) User {
    // Program Counter এখানে database call এ আছে
    // Thread waiting state এ যায়
    db.Query("SELECT * FROM users WHERE username = ?", username)
    
    // Database response এলে thread আবার active হয়
    return user
}
```

### Multiple Requests একসাথে:

```
Timeline:
------------------------------------------------------------
Time 0ms:   User 1 request → T2 created
            T2 PC = 0x9000 (parsing request)

Time 5ms:   User 2 request → T3 created
            T2 PC = 0x9100 (database query, WAITING)
            T3 PC = 0x9000 (parsing request)

Time 10ms:  User 3 request → T4 created
            T2: Still WAITING for DB
            T3 PC = 0x9100 (database query, WAITING)
            T4 PC = 0x9000 (parsing request)

Time 50ms:  User 1 এর DB response আসে
            T2 PC = 0x9200 (processing response)
            T3: Still WAITING
            T4 PC = 0x9100 (database query, WAITING)

Time 60ms:  User 1 এর response sent
            T2: TERMINATED
            T3 PC = 0x9200 (DB response পেয়েছে)
            T4: WAITING

সুবিধা: তিনটি user একসাথে service পাচ্ছে!
```

---

## Process vs Thread - তুলনা

| Feature | Process | Thread |
|---------|---------|--------|
| **Memory** | আলাদা memory space | একই memory share করে |
| **Creation Time** | বেশি সময় লাগে (1-10ms) | কম সময় লাগে (0.1-1ms) |
| **Communication** | IPC প্রয়োজন (Pipes, Sockets) | সহজ (shared memory) |
| **Context Switch** | Expensive | Cheap |
| **Resource** | বেশি resource লাগে | কম resource লাগে |
| **Crash Impact** | অন্য process এ প্রভাব নেই | পুরো process crash হয় |

---

## Context Switching

**Context Switch** হলো CPU যখন এক thread/process থেকে অন্য thread/process এ switch করে।

### Context Switch এর সময় কি হয়:

```
Thread T1 চলছে:
├── T1 এর state save করা:
│   ├── Program Counter (PC)
│   ├── Register values
│   ├── Stack pointer
│   └── Other CPU state
│
├── Scheduler নতুন thread নির্বাচন করে (T2)
│
└── T2 এর state restore করা:
    ├── PC load করা
    ├── Registers load করা
    └── Stack pointer set করা

এখন T2 চলতে শুরু করে
```

### উদাহরণ:

```
Music Player এ Context Switch:

Time 0-10ms: Audio Thread চলছে
  PC = 0x6000 → decodeAudio()
  Registers: R1=buffer_ptr, R2=sample_count

[Context Switch]
  Save: PC=0x6000, R1, R2, Stack
  Scheduler: UI Thread এর পালা

Time 10-15ms: UI Thread চলছে
  PC = 0x5000 → renderUI()
  Registers: R1=window_handle, R2=x_coord

[Context Switch]
  Save: PC=0x5000, R1, R2, Stack
  Scheduler: File I/O Thread এর পালা

Time 15-25ms: File I/O Thread চলছে
  PC = 0x7000 → readFile()
```

---

## Thread Safety এবং Synchronization

যখন একাধিক thread একই data access করে, তখন **race condition** হতে পারে।

### উদাহরণ - সমস্যা:

```
Shared Variable: playCount = 100

Thread 1 (T1):          Thread 2 (T2):
PC = 0xA000            PC = 0xB000
LOAD R1, playCount     LOAD R1, playCount
R1 = 100               R1 = 100
ADD R1, 1              ADD R1, 1
R1 = 101               R1 = 101
STORE R1, playCount    STORE R1, playCount
playCount = 101        playCount = 101

Expected: 102
Actual: 101 (ভুল!)
```

### সমাধান - Mutex (Mutual Exclusion):

```go
var playCount int = 0
var mutex sync.Mutex

// Thread 1
func incrementPlay() {
    mutex.Lock()        // Lock নেওয়া
    playCount++         // Critical section
    mutex.Unlock()      // Lock ছাড়া
}

// Thread 2
func incrementPlay() {
    mutex.Lock()        // অপেক্ষা করবে T1 unlock না করা পর্যন্ত
    playCount++
    mutex.Unlock()
}
```

---

## Interview এর জন্য গুরুত্বপূর্ণ পয়েন্ট

### ১. Process এবং Thread এর পার্থক্য বলতে পারবেন
- Memory isolation vs shared memory
- Creation cost
- Communication mechanism

### ২. Program Counter ব্যাখ্যা করতে পারবেন
- কোন instruction execute হচ্ছে তা track করে
- Context switch এ save/restore হয়
- প্রতিটি thread এর আলাদা PC থাকে

### ৩. Multi-threading এর সুবিধা
- Responsiveness (UI hang হয় না)
- Resource sharing (memory save হয়)
- Scalability (multiple CPU core use করতে পারে)
- Economy (process এর চেয়ে সস্তা)

### ৪. Real-world উদাহরণ দিতে পারবেন
- Web server: প্রতিটি request আলাদা thread
- Music player: UI, audio, file I/O আলাদা thread
- Browser: প্রতিটি tab আলাদা process

### ৫. Synchronization সমস্যা
- Race condition কি
- Mutex/Lock কিভাবে কাজ করে
- Deadlock এড়ানো

### ৬. Go Language এর Goroutines
- Lightweight threads
- ১০০০+ goroutines সহজেই চালানো যায়
- Channel দিয়ে communication

---

## শেষ কথা

**মূল বিষয়:**
- **Process** = একটি চলমান program, আলাদা memory space
- **Thread** = Process এর ভিতরে lightweight execution unit, memory share করে
- **Program Counter** = বর্তমান instruction এর address
- **Multi-threading** = একসাথে একাধিক কাজ করার জন্য

এই concepts গুলো ভালো করে বুঝলে আপনি operating system, concurrent programming, এবং backend development এর interview এ ভালো করতে পারবেন।

**প্র্যাকটিস করুন:** Go, Java, বা Python দিয়ে multi-threaded program লিখে experiment করুন!