# Go Defer - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ó‡¶æ‡¶á‡¶° (Complete  Guide)

## ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º Defer ‡¶ï‡¶ø? (What is Defer in Bangla?)

**Defer** ‡¶π‡¶≤‡ßã Go programming language ‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ keyword ‡¶Ø‡¶æ ‡¶ï‡ßã‡¶®‡ßã function call ‡¶ï‡ßá ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶ó ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶¨‡¶ø‡¶≤‡¶Æ‡ßç‡¶¨‡¶ø‡¶§ (postpone) ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡ßá‡•§

### ‡¶∏‡¶π‡¶ú ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º:
‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡¶ñ‡¶® `defer` keyword ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡¶®, ‡¶§‡¶ñ‡¶® Go ‡¶¨‡¶≤‡ßá: "‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá, ‡¶è‡¶á ‡¶ï‡¶æ‡¶ú‡¶ü‡¶æ ‡¶è‡¶ñ‡¶® ‡¶®‡¶æ, function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶ó‡ßá ‡¶ï‡¶∞‡¶¨‡ßã‡•§" ‡¶è‡¶ü‡¶æ ‡¶è‡¶ï‡¶ü‡¶æ magic box ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá ‡¶ï‡¶æ‡¶ú‡¶ó‡ßÅ‡¶≤‡ßã ‡¶ú‡¶Æ‡¶æ ‡¶π‡¶Ø‡¶º‡ßá ‡¶•‡¶æ‡¶ï‡ßá ‡¶è‡¶¨‡¶Ç function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã execute ‡¶π‡¶Ø‡¶º‡•§

### ‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®?
- File ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø (Close files)
- Database connection ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
- Mutex unlock ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
- Resource cleanup ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
- Panic ‡¶•‡ßá‡¶ï‡ßá recover ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø

---

## Defer ‡¶è‡¶∞ ‡¶Æ‡ßÇ‡¶≤ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ‡¶æ‡¶¨‡¶≤‡ßÄ (Core Rules)

### 1. LIFO (Last In, First Out) - ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ï ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞
‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï defer ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã **‡¶â‡¶≤‡ßç‡¶ü‡ßã ‡¶ï‡ßç‡¶∞‡¶Æ‡ßá** execute ‡¶π‡¶Ø‡¶º‡•§ ‡¶∂‡ßá‡¶∑‡ßá ‡¶Ø‡ßá‡¶ü‡¶æ defer ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá execute ‡¶π‡¶¨‡ßá‡•§

```go
func example() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
}
// Output:
// Third
// Second
// First
```

### 2. Arguments Evaluate Immediately
Defer function ‡¶è‡¶∞ arguments ‡¶§‡ßé‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡ßé evaluate ‡¶π‡¶Ø‡¶º, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ function call ‡¶¨‡¶ø‡¶≤‡¶Æ‡ßç‡¶¨‡¶ø‡¶§ ‡¶π‡¶Ø‡¶º‡•§

```go
func example() {
    x := 10
    defer fmt.Println(x) // x ‡¶è‡¶∞ value ‡¶è‡¶ñ‡¶æ‡¶®‡ßá‡¶á 10 ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá store ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá
    x = 20
}
// Output: 10 (not 20!)
```

### 3. Execution Timing
Defer functions execute ‡¶π‡¶Ø‡¶º:
- ‡¶∏‡¶¨ statement execute ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶™‡¶∞
- Return statement ‡¶è‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶ó‡ßá
- Function ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßá‡¶∞ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá

---

## Named Return Values vs Regular Return

‡¶è‡¶ü‡¶æ‡¶á ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ code ‡¶è‡¶∞ ‡¶Æ‡ßÇ‡¶≤ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º! ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡ßÅ‡¶ü‡ßã ‡¶≠‡¶ø‡¶®‡ßç‡¶® behavior ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§

### Case 1: Named Return Values (`calculateVal`)

```go
func calculateVal() (result int) {  // result ‡¶π‡¶≤‡ßã named return variable
    fmt.Println("first", result)     // 0
    show := func() {
       result = result + 10          // ‡¶è‡¶á ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® return value ‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡¶≠‡¶æ‡¶¨‡¶ø‡¶§ ‡¶ï‡¶∞‡¶¨‡ßá
       fmt.Println("defer", result)  // 15
    }
    defer show()
    result = 5
    fmt.Println("second", result)    // 5
    return  // ‡¶∂‡ßÅ‡¶ß‡ßÅ return, ‡¶ï‡ßã‡¶®‡ßã value ‡¶®‡ßá‡¶á
}
```

**Execution Flow:**
1. `result` initialize ‡¶π‡¶Ø‡¶º 0 ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá
2. `first 0` print ‡¶π‡¶Ø‡¶º
3. `defer show()` magic box ‡¶è ‡¶ú‡¶Æ‡¶æ ‡¶π‡¶Ø‡¶º
4. `result = 5` set ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º
5. `second 5` print ‡¶π‡¶Ø‡¶º
6. Return ‡¶è‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶ó‡ßá `show()` execute ‡¶π‡¶Ø‡¶º, `result = 15` ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º
7. Function return ‡¶ï‡¶∞‡ßá `result` ‡¶è‡¶∞ value ‡¶Ø‡¶æ ‡¶π‡¶≤‡ßã **15**

**Output:**
```
first 0
second 5
defer 15
main first 15
```

### Case 2: Regular Return (`calcVal`)

```go
func calcVal() int {  // ‡¶∂‡ßÅ‡¶ß‡ßÅ return type, named variable ‡¶®‡ßá‡¶á
    result := 0
    fmt.Println("first", result)     // 0
    show := func() {
       result = result + 10          // ‡¶è‡¶á ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® return value ‡¶ï‡ßá ‡¶™‡ßç‡¶∞‡¶≠‡¶æ‡¶¨‡¶ø‡¶§ ‡¶ï‡¶∞‡¶¨‡ßá ‡¶®‡¶æ
       fmt.Println("defer", result)  // 10
    }
    defer show()
    result = 5
    fmt.Println("second", result)    // 5
    return result  // ‡¶è‡¶ñ‡¶æ‡¶®‡ßá result ‡¶è‡¶∞ value (5) ‡¶§‡ßé‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡ßé evaluate ‡¶π‡¶Ø‡¶º
}
```

**Execution Flow:**
1. `result := 0` local variable ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá
2. `first 0` print ‡¶π‡¶Ø‡¶º
3. `defer show()` magic box ‡¶è ‡¶ú‡¶Æ‡¶æ ‡¶π‡¶Ø‡¶º
4. `result = 5` set ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º
5. `second 5` print ‡¶π‡¶Ø‡¶º
6. `return result` statement ‡¶è **return value (5) ‡¶è‡¶ñ‡¶æ‡¶®‡ßá‡¶á fixed ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º**
7. Defer function execute ‡¶π‡¶Ø‡¶º, `result = 10` ‡¶π‡¶Ø‡¶º ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ return value ‡¶Ü‡¶ó‡ßá‡¶á fix ‡¶π‡¶Ø‡¶º‡ßá ‡¶ó‡ßá‡¶õ‡ßá
8. Function return ‡¶ï‡¶∞‡ßá **5**

**Output:**
```
first 0
second 5
defer 10
main second 5
```

---

## Defer List/Pointer ‡¶è‡¶∞ ‡¶ß‡¶æ‡¶∞‡¶£‡¶æ (Defer List Pointer Concept)

Go runtime internally ‡¶è‡¶ï‡¶ü‡¶æ **defer list** ‡¶¨‡¶æ **defer stack** maintain ‡¶ï‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø goroutine ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§ ‡¶è‡¶ü‡¶æ ‡¶π‡¶≤‡ßã ‡¶è‡¶ï‡¶ü‡¶æ linked list ‡¶Ø‡ßá‡¶ñ‡¶æ‡¶®‡ßá defer ‡¶ï‡¶∞‡¶æ function ‡¶ó‡ßÅ‡¶≤‡ßã store ‡¶•‡¶æ‡¶ï‡ßá‡•§

### Internal Structure (Simplified):

```
Goroutine
    |
    +-- Defer Stack (Linked List)
            |
            +-- Defer 3 (Top/Most Recent)
            |
            +-- Defer 2
            |
            +-- Defer 1 (Bottom/Oldest)
```

### ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá:

1. **Defer Call:** ‡¶Ø‡¶ñ‡¶® `defer` statement execute ‡¶π‡¶Ø‡¶º, Go ‡¶è‡¶ï‡¶ü‡¶æ defer record ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç stack ‡¶è‡¶∞ top ‡¶è push ‡¶ï‡¶∞‡ßá
2. **Store Information:**
    - Function pointer
    - Arguments (evaluated values)
    - Stack frame information
3. **Function Return:** ‡¶Ø‡¶ñ‡¶® function return ‡¶ï‡¶∞‡¶§‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º, Go defer stack traverse ‡¶ï‡¶∞‡ßá (top ‡¶•‡ßá‡¶ï‡ßá bottom ‡¶è) ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ defer function execute ‡¶ï‡¶∞‡ßá
4. **Cleanup:** Execute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞ defer record remove ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º

### Memory Allocation:
- Go 1.13 ‡¶è‡¶∞ ‡¶Ü‡¶ó‡ßá: Defer calls heap ‡¶è allocate ‡¶π‡¶§‡ßã (slower)
- Go 1.13+: Most defer calls stack ‡¶è allocate ‡¶π‡¶Ø‡¶º (faster, zero allocation)
- Go 1.14+: ‡¶Ü‡¶∞‡ßã optimized, open-coded defers

---

##  Questions & Answers

### Q1: Defer ‡¶ï‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º?

**Answer:** Defer ‡¶è‡¶ï‡¶ü‡¶ø Go keyword ‡¶Ø‡¶æ function call ‡¶ï‡ßá current function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶Ü‡¶ó ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ postpone ‡¶ï‡¶∞‡ßá‡•§ ‡¶è‡¶ü‡¶æ ‡¶Æ‡ßÇ‡¶≤‡¶§ resource cleanup ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º, ‡¶Ø‡ßá‡¶Æ‡¶® file close ‡¶ï‡¶∞‡¶æ, lock release ‡¶ï‡¶∞‡¶æ, ‡¶¨‡¶æ connection ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ‡•§ Defer ensure ‡¶ï‡¶∞‡ßá ‡¶Ø‡ßá cleanup code ‡¶Ö‡¶¨‡¶∂‡ßç‡¶Ø‡¶á execute ‡¶π‡¶¨‡ßá, ‡¶è‡¶Æ‡¶®‡¶ï‡¶ø panic ‡¶π‡¶≤‡ßá‡¶ì‡•§

### Q2: Multiple defer statements ‡¶ï‡ßã‡¶® order ‡¶è execute ‡¶π‡¶Ø‡¶º?

**Answer:** LIFO (Last In, First Out) order ‡¶è, ‡¶Ö‡¶∞‡ßç‡¶•‡¶æ‡ßé stack ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã‡•§ ‡¶∂‡ßá‡¶∑‡ßá ‡¶Ø‡ßá defer add ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá ‡¶∏‡ßá‡¶ü‡¶æ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá execute ‡¶π‡¶¨‡ßá‡•§

```go
defer fmt.Println("1")
defer fmt.Println("2")
defer fmt.Println("3")
// Output: 3, 2, 1
```

### Q3: Defer function ‡¶è‡¶∞ arguments ‡¶ï‡¶ñ‡¶® evaluate ‡¶π‡¶Ø‡¶º?

**Answer:** Defer statement execute ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º‡ßá‡¶á arguments evaluate ‡¶π‡¶Ø‡¶º, function call ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶®‡¶Ø‡¶º‡•§

```go
x := 10
defer fmt.Println(x)  // 10 ‡¶è‡¶ñ‡¶æ‡¶®‡ßá‡¶á store ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶Ø‡¶º
x = 20
// Output: 10 (not 20)
```

### Q4: Named return values ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá defer ‡¶è‡¶∞ behavior ‡¶ï‡¶ø?

**Answer:** Named return values ‡¶è‡¶∞ ‡¶ï‡ßç‡¶∑‡ßá‡¶§‡ßç‡¶∞‡ßá defer function ‡¶∏‡ßá‡¶á variable modify ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç ‡¶∏‡ßá‡¶ü‡¶æ final return value ‡¶ï‡ßá affect ‡¶ï‡¶∞‡¶¨‡ßá, ‡¶ï‡¶æ‡¶∞‡¶£ return statement execute ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá defer execute ‡¶π‡¶Ø‡¶º‡•§

```go
func example() (result int) {
    defer func() { result++ }()
    return 5
}
// Returns: 6 (not 5)
```

### Q5: Defer ‡¶è‡¶∞ performance impact ‡¶ï‡¶ø?

**Answer:** Go 1.13+ ‡¶è defer ‡¶Ö‡¶®‡ßá‡¶ï efficient ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ defer ‡¶è‡¶∞ overhead minimal (around 1-2 ns per call)‡•§ Critical performance path ‡¶õ‡¶æ‡¶°‡¶º‡¶æ ‡¶∏‡¶¨ ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ‡¶Ø‡¶º defer ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ safe ‡¶è‡¶¨‡¶Ç recommended‡•§

### Q6: Defer ‡¶ï‡¶ø panic recover ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá?

**Answer:** ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å, defer ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá `recover()` call ‡¶ï‡¶∞‡ßá panic ‡¶•‡ßá‡¶ï‡ßá recover ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡•§

```go
func example() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()
    panic("something went wrong")
}
```

### Q7: Loop ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá defer ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶ï‡¶ø safe?

**Answer:** ‡¶®‡¶æ, ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ loop ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá defer ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶â‡¶ö‡¶ø‡¶§ ‡¶®‡¶Ø‡¶º ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶∏‡¶¨ defer calls function ‡¶∂‡ßá‡¶∑‡ßá execute ‡¶π‡¶¨‡ßá, loop iteration ‡¶∂‡ßá‡¶∑‡ßá ‡¶®‡¶Ø‡¶º‡•§ ‡¶è‡¶§‡ßá memory leak ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

```go
// Bad Practice
for i := 0; i < 100; i++ {
    f, _ := os.Open(files[i])
    defer f.Close()  // ‡¶∏‡¶¨ files function ‡¶∂‡ßá‡¶∑‡ßá close ‡¶π‡¶¨‡ßá
}

// Good Practice
for i := 0; i < 100; i++ {
    func() {
        f, _ := os.Open(files[i])
        defer f.Close()  // ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶æ iteration ‡¶è close ‡¶π‡¶¨‡ßá
    }()
}
```

### Q8: Defer vs finally (Java/Python) ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶ï‡¶ø?

**Answer:**
- **Defer:** Function-scoped, stack-based, specific to function calls
- **Finally:** Block-scoped, exception handling ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá tied
- Defer ‡¶∂‡ßÅ‡¶ß‡ßÅ function calls ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶∏‡ßá‡¶ü‡¶æ cleaner ‡¶è‡¶¨‡¶Ç more idiomatic in Go

### Q9: Defer function ‡¶è pointer modify ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ï‡¶ø ‡¶π‡¶Ø‡¶º?

**Answer:** ‡¶Ø‡¶¶‡¶ø defer function pointer ‡¶è‡¶∞ ‡¶Æ‡¶æ‡¶ß‡ßç‡¶Ø‡¶Æ‡ßá value modify ‡¶ï‡¶∞‡ßá, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶∏‡ßá‡¶á ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® reflect ‡¶π‡¶¨‡ßá, ‡¶ï‡¶æ‡¶∞‡¶£ pointer evaluate ‡¶π‡¶≤‡ßá‡¶ì ‡¶∏‡ßá‡¶ü‡¶æ same memory location point ‡¶ï‡¶∞‡¶õ‡ßá‡•§

```go
func example() {
    x := 10
    defer func(val *int) {
        *val = 20
    }(&x)
    fmt.Println(x)  // 10
}
// After defer: x = 20
```

### Q10: Defer ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá return statement ‡¶è‡¶∞ exact order ‡¶ï‡¶ø?

**Answer:**
1. Return value(s) evaluate ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º
2. Named return variables ‡¶è assign ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º (‡¶Ø‡¶¶‡¶ø ‡¶•‡¶æ‡¶ï‡ßá)
3. Defer functions execute ‡¶π‡¶Ø‡¶º (LIFO order ‡¶è)
4. Function actually return ‡¶ï‡¶∞‡ßá

---

## Common Patterns & Best Practices

### Pattern 1: Resource Cleanup
```go
func readFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()  // Ensure file is always closed
    
    // Read file operations
    return nil
}
```

### Pattern 2: Mutex Lock/Unlock
```go
func updateData() {
    mu.Lock()
    defer mu.Unlock()  // Ensure lock is always released
    
    // Critical section
}
```

### Pattern 3: Timing Function Execution
```go
func timeTrack(start time.Time, name string) {
    elapsed := time.Since(start)
    fmt.Printf("%s took %s\n", name, elapsed)
}

func expensiveOperation() {
    defer timeTrack(time.Now(), "expensiveOperation")
    // Operation logic
}
```

### Pattern 4: Panic Recovery
```go
func safeExecute() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered:", r)
        }
    }()
    // Risky operations
}
```

---

## Common Mistakes to Avoid

### ‚ùå Mistake 1: Defer in Loops
```go
// Wrong
for _, file := range files {
    f, _ := os.Open(file)
    defer f.Close()  // All files close ‡¶ï‡¶∞‡¶¨‡ßá function ‡¶∂‡ßá‡¶∑‡ßá
}

// Correct
for _, file := range files {
    func(filename string) {
        f, _ := os.Open(filename)
        defer f.Close()
    }(file)
}
```

### ‚ùå Mistake 2: Ignoring Defer Return Values
```go
// Wrong
defer file.Close()

// Better
defer func() {
    if err := file.Close(); err != nil {
        log.Printf("Error closing file: %v", err)
    }
}()
```

### ‚ùå Mistake 3: Defer with Nil Pointers
```go
// Wrong
var f *os.File
defer f.Close()  // Panic if f is nil

// Correct
var f *os.File
if f != nil {
    defer f.Close()
}
```

---

## Code Output Analysis (Your Example)

### Full Program Output:
```
first 0
second 5
defer 15
main first 15
first 0
second 5
defer 10
main second 5
```

### Why Different Results?

**calculateVal (Named Return):**
- `result` is a **named return parameter**
- Defer function modifies `result` **before** return
- Final return value: **15**

**calcVal (Regular Return):**
- `result` is a **local variable**
- `return result` evaluates to 5 **immediately**
- Defer modifies local variable **after** return value is fixed
- Final return value: **5**

---

## Quick Reference Cheat Sheet

| Feature | Behavior |
|---------|----------|
| Execution Order | LIFO (Last In, First Out) |
| Argument Evaluation | Immediate (when defer is called) |
| Execution Timing | Just before function returns |
| Named Returns | Defer can modify return value |
| Regular Returns | Return value fixed before defer |
| Panic Handling | Defer still executes during panic |
| Loop Usage | Avoid (use anonymous function) |
| Performance | Minimal overhead (Go 1.13+) |

---

## Summary (‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™)

**Defer ‡¶π‡¶≤‡ßã Go ‡¶è‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø powerful feature ‡¶Ø‡¶æ:**
- Resource cleanup ‡¶∏‡¶π‡¶ú ‡¶è‡¶¨‡¶Ç safe ‡¶ï‡¶∞‡ßá
- Code readability ‡¶¨‡¶æ‡¶°‡¶º‡¶æ‡¶Ø‡¶º
- Error prone code ‡¶ï‡¶Æ‡¶æ‡¶Ø‡¶º
- Panic recovery enable ‡¶ï‡¶∞‡ßá

**‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶¨‡ßá‡¶®:**
1. Defer = "‡¶è‡¶á ‡¶ï‡¶æ‡¶ú‡¶ü‡¶æ function ‡¶∂‡ßá‡¶∑‡ßá ‡¶ï‡¶∞‡ßã"
2. Multiple defers = Stack order (LIFO)
3. Arguments = ‡¶§‡ßé‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡ßé evaluate
4. Named returns = Defer modify ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
5. Loops ‡¶è ‡¶∏‡¶§‡¶∞‡ßç‡¶ï ‡¶•‡¶æ‡¶ï‡ßÅ‡¶®

** ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø focus ‡¶ï‡¶∞‡ßÅ‡¶®:**
- Named vs regular return behavior
- LIFO execution order
- Common use cases (file, lock, panic)
- Performance characteristics
- Common pitfalls (loops, nil pointers)

---

## Additional Resources

- [Official Go Documentation on Defer](https://go.dev/blog/defer-panic-and-recover)
- [Effective Go - Defer](https://go.dev/doc/effective_go#defer)
- [Go Specification - Defer Statements](https://go.dev/ref/spec#Defer_statements)

---



# üß† Go `defer` ‚Äì Complete Rules & Tricks (Bangla)

‡¶è‡¶á ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡¶ü‡¶ø Go ‡¶≠‡¶æ‡¶∑‡¶æ‡¶∞ `defer` ‡¶¨‡ßÅ‡¶ù‡ßá ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø **Bangla Cheat Sheet**‡•§
Beginner ‡¶•‡ßá‡¶ï‡ßá Interview ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶ï‡¶æ‡¶ú‡ßá ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá‡•§

---

## üîπ 1. `defer` ‡¶ï‡¶ñ‡¶® execute ‡¶π‡ßü?

* `defer` **‡¶∏‡¶¨‡¶∏‡¶Æ‡ßü function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶ì‡ßü‡¶æ‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶ó‡ßá execute ‡¶π‡ßü**
* Line-by-line execute ‡¶π‡ßü ‡¶®‡¶æ

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï ‡¶Æ‡¶®‡ßá ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®:**
üëâ *defer ‡¶Æ‡¶æ‡¶®‡ßá ‚Äî ‡¶∂‡ßá‡¶∑‡ßá ‡¶ï‡¶∞‡¶¨‡ßã*

---

## üîπ 2. `defer` ‡¶ï‡ßã‡¶® scope ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?

* `defer` **‡¶Ø‡ßá‡¶á function ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞‡ßá ‡¶≤‡ßá‡¶ñ‡¶æ ‡¶π‡ßü**
* ‡¶∏‡ßá‡¶á function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá execute ‡¶π‡ßü

‚ùå Loop ‡¶∂‡ßá‡¶∑ ‡¶Æ‡¶æ‡¶®‡ßá‡¶á `defer` ‡¶ö‡¶≤‡¶¨‡ßá ‚Äî ‡¶è‡¶ü‡¶æ ‡¶≠‡ßÅ‡¶≤

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *loop ‚â† function*

---

## üîπ 3. ‡¶è‡¶ï‡¶æ‡¶ß‡¶ø‡¶ï `defer` ‡¶π‡¶≤‡ßá ‡¶ï‡ßÄ ‡¶π‡ßü?

* `defer` **LIFO (Last In First Out)** ‡¶®‡¶ø‡ßü‡¶Æ‡ßá ‡¶ö‡¶≤‡ßá
* Stack-‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá

```go
defer fmt.Println(1)
defer fmt.Println(2)
defer fmt.Println(3)
```

**Output**

```
3
2
1
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *‡¶∂‡ßá‡¶∑‡ßá ‡¶¢‡ßÅ‡¶ï‡ßá‡¶õ‡ßá, ‡¶Ü‡¶ó‡ßá ‡¶¨‡ßá‡¶∞ ‡¶π‡¶¨‡ßá*

---

## üîπ 4. `defer` arguments ‡¶ï‡¶ñ‡¶® evaluate ‡¶π‡ßü?

* `defer` ‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßü‡¶á arguments evaluate ‡¶π‡ßü
* execute ‡¶π‡¶ì‡ßü‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶®‡ßü

```go
x := 10
defer fmt.Println(x)
x = 20
```

**Output**

```
10
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *value ‡¶Ü‡¶ó‡ßá ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ü ‡¶π‡ßü*

---

## üîπ 5. `defer` + Loop (‚ö†Ô∏è Danger Zone)

* Loop ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞‡ßá `defer` ‡¶¶‡¶ø‡¶≤‡ßá
* ‡¶∏‡¶¨ defer **function ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá ‡¶è‡¶ï‡¶∏‡¶æ‡¶•‡ßá execute ‡¶π‡ßü**

```go
for i := 0; i < 3; i++ {
    defer fmt.Println(i)
}
```

**Output**

```
2
1
0
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *loop ‡¶∂‡ßá‡¶∑ ‚â† defer execute*

---

## üîπ 6. `defer` + Loop + Closure (üî• Biggest Trap)

```go
for _, v := range data {
    defer func() {
        fmt.Println(v)
    }()
}
```

**Output**

```
same value repeated
```

**‡¶ï‡¶æ‡¶∞‡¶£**

* Loop variable reuse ‡¶π‡ßü
* defer ‡¶™‡¶∞‡ßá execute ‡¶π‡ßü

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *closure ‡¶´‡¶æ‡¶Å‡¶¶‡ßá ‡¶´‡ßá‡¶≤‡¶¨‡ßá*

---

## üîπ 7. Loop + defer ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶®‡¶ø‡ßü‡¶Æ

### ‚úî Correct Way

```go
for _, v := range data {
    defer func(val int) {
        fmt.Println(val)
    }(v)
}
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *value parameter ‡¶è ‡¶™‡¶æ‡¶†‡¶æ‡¶ì*

---

## üîπ 8. `defer` resource cleanup ‡¶è ‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶π‡ßü?

* File close
* DB connection close
* Mutex unlock
* HTTP response body close

```go
file, _ := os.Open("test.txt")
defer file.Close()
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *‡¶ñ‡ßÅ‡¶≤‡¶≤‡ßá ‡¶∏‡¶ô‡ßç‡¶ó‡ßá ‡¶∏‡¶ô‡ßç‡¶ó‡ßá defer ‡¶ï‡¶∞‡ßã*

---

## üîπ 9. Loop ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞‡ßá resource + defer (‚ö†Ô∏è Warning)

* Loop ‡¶è resource open ‡¶ï‡¶∞‡ßá defer ‡¶ï‡¶∞‡¶≤‡ßá
* Resource leak ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá

‚ùå Bad

```go
for _, f := range files {
    file, _ := os.Open(f)
    defer file.Close()
}
```

‚úî Good

```go
for _, f := range files {
    func() {
        file, _ := os.Open(f)
        defer file.Close()
    }()
}
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *loop ‡¶è defer = ‡¶∏‡¶®‡ßç‡¶¶‡ßá‡¶π*

---

## üîπ 10. Named return variable ‡¶ï‡ßÄ?

```go
func test() (x int)
```

* `x` ‡¶Ü‡¶ó‡ßá ‡¶•‡ßá‡¶ï‡ßá‡¶á declare ‡¶•‡¶æ‡¶ï‡ßá
* Default value = 0
* `defer` ‡¶è‡¶á `x` ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *named return = mutable*

---

## üîπ 11. Named return + defer

* `defer` **return value ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá**

```go
func test() (x int) {
    defer func() {
        x += 5
    }()
    return
}
```

**Return Value**

```
5
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *named return = defer magic*

---

## üîπ 12. Normal (unnamed) return

```go
func test() int {
    x := 5
    defer func() {
        x += 5
    }()
    return x
}
```

* `return x` ‡¶è value ‡¶Ü‡¶ó‡ßá copy ‡¶π‡ßü
* `defer` return value ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá ‡¶®‡¶æ

**Return Value**

```
5
```

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *return ‡¶Ü‡¶ó‡ßá copy*

---

## üîπ 13. `return` + `defer` execution order

1. Return value evaluate ‡¶π‡ßü
2. Defer function execute ‡¶π‡ßü
3. Function exit ‡¶π‡ßü

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *return ‚Üí defer ‚Üí exit*

---

## üîπ 14. ‡¶ï‡¶ñ‡¶® `defer` ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶â‡¶ö‡¶ø‡¶§ ‡¶®‡ßü?

‚ùå Tight loop
‚ùå Performance critical code
‚ùå Massive iteration

**‡¶ü‡ßç‡¶∞‡¶ø‡¶ï:**
üëâ *fast code = no defer*

---

## üîπ 15. Interview Golden Lines ‚ú®

* **‚Äúdefer runs at function exit, not loop exit‚Äù**
* **‚Äúnamed return value can be modified by defer‚Äù**


// Go ‡¶§‡ßá defer ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡¶ø‡¶§ ‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ
/*
Named return values
---------------------------
1. ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶∏‡¶¨ ‡¶ï‡ßã‡¶° execute ‡¶π‡¶Ø‡¶º
2. defer function ‡¶ó‡ßÅ‡¶≤‡ßã stack ‡¶¨‡¶æ "magic box"-‡¶è store ‡¶π‡¶Ø‡¶º
3. return ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶ó‡ßá defer function ‡¶ó‡ßÅ‡¶≤‡ßã execute ‡¶π‡¶Ø‡¶º
4. return value ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá named variable-‡¶è‡¶∞ ‡¶∂‡ßá‡¶∑ ‡¶Æ‡¶æ‡¶® return ‡¶π‡¶Ø‡¶º


Normal (just) return types
---------------------------
1. ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá ‡¶∏‡¶¨ ‡¶ï‡ßã‡¶° execute ‡¶π‡¶Ø‡¶º
2. defer function ‡¶ó‡ßÅ‡¶≤‡ßã stack ‡¶¨‡¶æ "magic box"-‡¶è store ‡¶π‡¶Ø‡¶º
3. return value ‡¶§‡¶ñ‡¶®‡¶á evaluate ‡¶π‡¶Ø‡¶º; defer ‡¶Ø‡¶¶‡¶ø variable ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßá, return value ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§ ‡¶π‡¶Ø‡¶º ‡¶®‡¶æ
4. ‡¶∏‡¶¨ defer function execute ‡¶π‡¶Ø‡¶º
   */

