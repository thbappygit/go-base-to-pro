# Context Switching, PCB এবং Go Concurrency

## সূচিপত্র
1. [Context Switching কী?](#context-switching-কী)
2. [Process Control Block (PCB)](#process-control-block-pcb)
3. [OS এবং CPU এর ভূমিকা](#os-এবং-cpu-এর-ভূমিকা)
4. [Go তে Concurrency](#go-তে-concurrency)

---

## Context Switching কী?

**Context Switching** হলো একটি প্রক্রিয়া যেখানে CPU একটি প্রসেস বা থ্রেড থেকে অন্য একটি প্রসেস বা থ্েডে সুইচ করে। এটি মাল্টিটাস্কিং অপারেটিং সিস্টেমের একটি মূল বৈশিষ্ট্য।

### Context Switching এর ধাপসমূহ:

```
┌─────────────────────────────────────────────────────────┐
│                  Context Switching Process               │
└─────────────────────────────────────────────────────────┘

   Process A চলছে                Process B চলছে
   ┌──────────┐                  ┌──────────┐
   │   CPU    │                  │   CPU    │
   │ Running  │                  │ Running  │
   │Process A │                  │Process B │
   └──────────┘                  └──────────┘
        │                              ▲
        │ ① সেভ করুন                  │ ④ লোড করুন
        │   Context                    │   Context
        ▼                              │
   ┌──────────┐                  ┌──────────┐
   │   PCB    │─────────────────▶│   PCB    │
   │Process A │  ② সিলেক্ট করুন │Process B │
   │          │     Process B     │          │
   └──────────┘                  └──────────┘
                  ③ সেভ সম্পন্ন
```

### Context Switching কেন প্রয়োজন?

1. **মাল্টিটাস্কিং**: একাধিক প্রোগ্রাম একই সাথে চালানোর জন্য
2. **CPU Utilization**: CPU সম্পদের সর্বোচ্চ ব্যবহার নিশ্চিত করা
3. **Response Time**: ব্যবহারকারীর অভিজ্ঞতা উন্নত করা
4. **Priority Scheduling**: গুরুত্বপূর্ণ কাজগুলো আগে সম্পন্ন করা

---

## Process Control Block (PCB)

**PCB** হলো একটি ডেটা স্ট্রাকচার যা অপারেটিং সিস্টেম প্রতিটি প্রসেসের তথ্য সংরক্ষণ করতে ব্যবহার করে।

### PCB এর গঠন:

```
┌─────────────────────────────────────────────┐
│        Process Control Block (PCB)          │
├─────────────────────────────────────────────┤
│  Process ID (PID): 1234                     │
├─────────────────────────────────────────────┤
│  Process State: Running/Ready/Waiting       │
├─────────────────────────────────────────────┤
│  Program Counter (PC): 0x00401000           │
├─────────────────────────────────────────────┤
│  CPU Registers:                             │
│    - EAX: 0x12345678                        │
│    - EBX: 0xABCDEF00                        │
│    - ECX, EDX, ESI, EDI...                  │
├─────────────────────────────────────────────┤
│  Memory Management Info:                    │
│    - Base Address                           │
│    - Limit Address                          │
│    - Page Tables                            │
├─────────────────────────────────────────────┤
│  I/O Status Information:                    │
│    - Open Files                             │
│    - I/O Devices                            │
├─────────────────────────────────────────────┤
│  Scheduling Information:                    │
│    - Priority                               │
│    - Scheduling Queue Pointers              │
├─────────────────────────────────────────────┤
│  Accounting Information:                    │
│    - CPU Time Used                          │
│    - Time Limits                            │
└─────────────────────────────────────────────┘
```

### PCB এর প্রধান উপাদান:

1. **Process ID (PID)**: প্রসেসের ইউনিক আইডেন্টিফায়ার
2. **Process State**: বর্তমান অবস্থা (New, Ready, Running, Waiting, Terminated)
3. **Program Counter**: পরবর্তী ইন্সট্রাকশনের অ্যাড্রেস
4. **CPU Registers**: সকল রেজিস্টারের মান
5. **Memory Information**: মেমোরি অ্যালোকেশনের তথ্য
6. **I/O Status**: ওপেন ফাইল এবং ডিভাইসের তথ্য

---

## OS এবং CPU এর ভূমিকা

### Process State Diagram:

```
                    ┌──────────┐
                    │   New    │
                    └────┬─────┘
                         │
                         ▼
    ┌──────────┐    ┌────────┐    ┌──────────┐
    │Terminated│◀───│ Ready  │───▶│ Running  │
    └──────────┘    └────┬───┘    └────┬─────┘
                         ▲             │
                         │             │
                         │   ┌─────────▼──────┐
                         └───│   Waiting/     │
                             │   Blocked      │
                             └────────────────┘
```

### Context Switching এ OS এর কাজ:

```
┌──────────────────────────────────────────────────────┐
│              Operating System Kernel                  │
├──────────────────────────────────────────────────────┤
│                                                       │
│  ┌────────────────┐        ┌─────────────────┐     │
│  │   Scheduler    │◀──────▶│  Dispatcher     │     │
│  │                │        │                 │     │
│  │ - নির্বাচন     │        │ - Context সেভ   │     │
│  │ - Priority     │        │ - Context লোড   │     │
│  │ - Algorithm    │        │ - Mode Switch   │     │
│  └────────────────┘        └─────────────────┘     │
│           │                         │                │
│           ▼                         ▼                │
│  ┌────────────────────────────────────────┐         │
│  │         Process Queue                   │         │
│  │  [P1]─[P2]─[P3]─[P4]─[P5]              │         │
│  └────────────────────────────────────────┘         │
└──────────────────────────────────────────────────────┘
                       │
                       ▼
              ┌────────────────┐
              │   CPU Core     │
              │                │
              │  Execute       │
              │  Instructions  │
              └────────────────┘
```

### CPU এর কাজ:

1. **Instruction Execution**: ইন্সট্রাকশন এক্সিকিউট করা
2. **Register Management**: রেজিস্টারের মান পরিবর্তন করা
3. **Interrupt Handling**: ইন্টারাপ্ট হ্যান্ডল করা
4. **Mode Switching**: User mode এবং Kernel mode এর মধ্যে সুইচ করা

---

## Go তে Concurrency

Go প্রোগ্রামিং ভাষায় **Goroutines** এবং **Channels** ব্যবহার করে concurrency অর্জন করা হয়।

### Goroutines vs OS Threads:

```
┌─────────────────────────────────────────────────────┐
│            Traditional OS Threading                  │
├─────────────────────────────────────────────────────┤
│                                                      │
│  Thread 1      Thread 2      Thread 3               │
│  ┌──────┐     ┌──────┐     ┌──────┐               │
│  │ 2 MB │     │ 2 MB │     │ 2 MB │  (Stack Size) │
│  └──┬───┘     └──┬───┘     └──┬───┘               │
│     │            │            │                     │
│     └────────────┴────────────┘                     │
│                  │                                   │
│            ┌─────▼──────┐                           │
│            │   Kernel   │                           │
│            │  Scheduler │  (Heavy Context Switch)   │
│            └────────────┘                           │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│              Go Runtime (Goroutines)                 │
├─────────────────────────────────────────────────────┤
│                                                      │
│  G1     G2     G3     G4     G5                     │
│  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐                     │
│  │2K│  │2K│  │2K│  │2K│  │2K│  (Stack Size)       │
│  └─┬┘  └─┬┘  └─┬┘  └─┬┘  └─┬┘                     │
│    └─────┴─────┴─────┴─────┘                        │
│              │                                       │
│        ┌─────▼──────┐                               │
│        │   M:N      │                               │
│        │ Scheduler  │  (Light Context Switch)       │
│        └─────┬──────┘                               │
│              │                                       │
│    ┌─────────┴──────────┐                           │
│    │   OS Threads (M)   │                           │
│    │   P1   P2   P3     │  (Processors)             │
│    └────────────────────┘                           │
└─────────────────────────────────────────────────────┘
```

### Go Scheduler - GMP Model:

```
┌────────────────────────────────────────────────────┐
│           Go Runtime Scheduler (GMP)                │
└────────────────────────────────────────────────────┘

G = Goroutine (হালকা থ্রেড)
M = Machine (OS Thread)
P = Processor (Context/Resource)

    G1   G2   G3   G4   G5   G6   G7   G8
    │    │    │    │    │    │    │    │
    │    │    │    │    │    │    │    │
    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼
┌────────────────────────────────────────────┐
│         Global Runnable Queue              │
└────────────────────────────────────────────┘
            │              │
            ▼              ▼
    ┌───────────┐  ┌───────────┐
    │   P1      │  │   P2      │
    │ ┌───────┐ │  │ ┌───────┐ │
    │ │Local  │ │  │ │Local  │ │
    │ │Queue  │ │  │ │Queue  │ │
    │ │[G][G] │ │  │ │[G][G] │ │
    │ └───┬───┘ │  │ └───┬───┘ │
    └─────┼─────┘  └─────┼─────┘
          │              │
          ▼              ▼
    ┌─────────┐    ┌─────────┐
    │   M1    │    │   M2    │
    │(OS      │    │(OS      │
    │ Thread) │    │ Thread) │
    └────┬────┘    └────┬────┘
         │              │
         ▼              ▼
    ┌──────────────────────┐
    │    CPU Cores         │
    │   Core1    Core2     │
    └──────────────────────┘
```

### Go Concurrency উদাহরণ:

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// Worker function যা Goroutine হিসেবে চলবে
func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        fmt.Printf("Worker %d শুরু করেছে job %d\n", id, job)
        time.Sleep(time.Second) // কাজের সিমুলেশন
        fmt.Printf("Worker %d শেষ করেছে job %d\n", id, job)
        results <- job * 2
    }
}

func main() {
    const numJobs = 5
    const numWorkers = 3
    
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    var wg sync.WaitGroup
    
    // Workers তৈরি করুন
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go worker(w, jobs, results, &wg)
    }
    
    // Jobs পাঠান
    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)
    
    // Results সংগ্রহ করার জন্য goroutine
    go func() {
        wg.Wait()
        close(results)
    }()
    
    // Results প্রিন্ট করুন
    for result := range results {
        fmt.Printf("Result: %d\n", result)
    }
}
```

### Goroutine Context Switching:

```
সময়: T1              T2              T3              T4
     │               │               │               │
     ▼               ▼               ▼               ▼
P1: [G1 Running]─▶[G2 Running]─▶[G3 Running]─▶[G1 Running]
     │               │               │               │
     │   সুইচ        │   সুইচ        │   সুইচ        │
     │   (ব্লক)      │   (ইয়েল্ড)    │   (টাইম স্লাইস)│
     ▼               ▼               ▼               ▼

Stack সেভ করা হয়:
- শুধু Goroutine এর স্ট্যাক পয়েন্টার
- প্রোগ্রাম কাউন্টার
- কয়েকটি রেজিস্টার

OS Thread সুইচিং এর চেয়ে অনেক দ্রুত!
```

### Context Switching এর তুলনা:

| বৈশিষ্ট্য | OS Thread | Goroutine |
|---------|-----------|-----------|
| Stack Size | 1-2 MB | 2 KB (শুরুতে) |
| Context Switch সময় | 1-2 মাইক্রোসেকেন্ড | ~200 ন্যানোসেকেন্ড |
| Memory Overhead | বেশি | কম |
| তৈরি করার খরচ | বেশি | কম |
| Scheduler | OS Kernel | Go Runtime |
| সর্বোচ্চ সংখ্যা | হাজার | লক্ষ |

---

## সারসংক্ষেপ

### Context Switching এর প্রক্রিয়া:

1. **বর্তমান প্রসেসের state সেভ করুন** PCB তে
2. **Scheduler নতুন প্রসেস নির্বাচন করুন**
3. **নতুন প্রসেসের state লোড করুন** PCB থেকে
4. **CPU নতুন প্রসেস এক্সিকিউট করুন**

### Go এর সুবিধা:

- **হালকা Goroutines**: কম মেমোরি ব্যবহার
- **দ্রুত Context Switching**: ন্যানোসেকেন্ড সময়
- **M:N Scheduling**: OS threads এর উপর অনেক Goroutines
- **Automatic Stack Management**: প্রয়োজন অনুযায়ী stack বৃদ্ধি
- **Built-in Concurrency**: channels এবং select statement

Go এর concurrency model অপারেটিং সিস্টেমের traditional threading মডেলের চেয়ে অনেক বেশি কার্যকর এবং স্কেলেবল।